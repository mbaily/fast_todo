{% extends 'base.html' %}

{% block title %}Calendar - Fast Todo{% endblock %}

{% block content %}
<!-- DEBUG_TEMPLATE_ID: 20250825-1 -->
  <style>
    /* remove top gap so toolbar sits flush to the top on calendar page */
    body { margin-top: 0 !important; }
    header { margin-top: 0 !important; }
    /* hide server-rendered occurrences when JS is present; keep layout space to avoid reflow */
    .ft-js .todos-list { visibility: hidden; }
    /* calendar page: do not expand full-bleed container beyond 100% to avoid rounding-induced clipping */
    section.full-bleed.calendar-bleed { width: 100% !important; max-width: 100% !important; }
  </style>
  <script>
    // Mark page as JS-enabled as early as possible to avoid showing a mismatched
    // server-rendered list briefly before the client replaces it.
    try { document.documentElement.classList.add('ft-js'); } catch (e) {}
  </script>
  <section class="full-bleed calendar-bleed">
    <div style="display:flex; align-items:center; gap:0.5rem;">
      <h2>Calendar - {{ year }}-{{ '%02d'|format(month) }}</h2>
      <div style="margin-left:auto">
        <a class="button" href="/html_no_js/calendar?year={{ prev_year }}&month={{ prev_month }}">‚óÄ Prev</a>
        <a class="button" href="/html_no_js/calendar?year={{ next_year }}&month={{ next_month }}">Next ‚ñ∂</a>
      </div>
    </div>
    <div style="margin-top:0.5rem">
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="show_ignored"> Show ignored
      </label>
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-left:0.75rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="hide_completed"> Hide completed
      </label>
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-left:0.75rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="include_historic"> Include historic (show phantom completions)
      </label>
      {% if occurrences_sorted and occurrences_sorted|length > 0 %}
      <ul class="todos-list">
      {% for ev in occurrences_sorted %}
        <li class="todo">
            <div class="controls-left">
            <input type="checkbox" class="occ-complete" data-hash="{{ ev.occ_hash }}" data-item-type="{{ ev.item_type }}" data-item-id="{{ ev.id }}" data-occ-dt="{{ ev.occurrence_dt }}" data-phantom="{{ '1' if ev.phantom else '' }}" {% if ev.completed %}checked{% endif %} {% if ev.phantom %}disabled title="Historic completion (read-only)"{% endif %} aria-label="mark occurrence complete">
            <button type="button" class="occ-ignore-occ" data-occ="{{ ev.occ_hash }}" title="Ignore in calendar altogether." aria-label="Ignore this occurrence" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">üîï</button>
            <button type="button" class="occ-ignore-from" data-todo="{{ ev.id }}" data-occ-dt="{{ ev.occurrence_dt }}" title="Ignore from this date" aria-label="Ignore from this date" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚è≠Ô∏è</button>
          </div>
          <div class="todo-content">
            <div class="todo-main wrap-text">
              <div class="wrap-text" style="font-weight:700">
                {% if ev.item_type == 'todo' %}
                  <a href="/html_no_js/todos/{{ ev.id }}">{{ ev.title }}</a>
                {% elif ev.item_type == 'list' %}
                  <a href="/html_no_js/lists/{{ ev.id }}">{{ ev.title }}</a>
                {% else %}
                  {{ ev.title }}
                {% endif %}
              </div>
              <div class="meta">{{ ev.occurrence_date or ev.occurrence_dt }}</div>
            </div>
          </div>
        </li>
      {% endfor %}
      </ul>
      {% else %}
      <!-- Minimal skeleton list so JS can replace in-place -->
      <ul class="todos-list">
        <li class="todo">
          <div class="todo-content">
            <div class="todo-main wrap-text">
              <div class="meta">Loading calendar events...</div>
            </div>
          </div>
        </li>
      </ul>
      {% endif %}
    </div>
  </section>
  {% block scripts %}{{ super() }}

  <script>
  console.log('DEBUG: calendar page script loaded');
  // Abort controller for deduplicating fetches when users toggle options rapidly
  let __occFetchController = null;
  function setCookie(name, value, days) {
    let expires = '';
    if (days) { const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); expires = '; expires=' + d.toUTCString(); }
    document.cookie = name + '=' + (value || '')  + expires + '; path=/';
  }
  function getCookie(name) { const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)'); return v ? v.pop() : ''; }

  // Fetch occurrences for the current calendar window and replace the list
  async function fetchOccurrencesForCurrentWindow() {
    try {
      // Abort any in-flight request before starting a new one
      try { if (__occFetchController) { __occFetchController.abort(); } } catch(e) {}
      __occFetchController = (typeof AbortController !== 'undefined') ? new AbortController() : null;
      // no watchdog timer; rendering will proceed normally

      const params = new URLSearchParams(window.location.search);
      const year = parseInt(params.get('year') || '{{ year }}', 10);
      const month = parseInt(params.get('month') || '{{ month }}', 10);
      const start = new Date(Date.UTC(year, month-1, 1, 0,0,0));
      const lastDay = new Date(Date.UTC(year, month, 0)).getUTCDate();
      let end;
  const includeNext7 = getCookie('include_next7') === '1';
  const includeHistoric = getCookie('include_historic') === '1';
      if (includeNext7) {
        end = new Date(Date.UTC(year, month, 7, 23,59,59)).toISOString();
      } else {
        end = new Date(Date.UTC(year, month-1, lastDay, 23,59,59)).toISOString();
      }
      
      const startIso = start.toISOString();
      const showIgnored = getCookie('show_ignored') === '1';
      const maxTotal = 3000; // UI safety cap to limit payload size
  const q = `/calendar/occurrences?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(end)}&include_ignored=${showIgnored ? '1' : '0'}&include_historic=${includeHistoric ? '1' : '0'}&max_total=${maxTotal}`;
      const res = await fetch(q, { credentials: 'same-origin', signal: __occFetchController ? __occFetchController.signal : undefined });
      if (!res.ok) {
        console.error('DEBUG: fetchOccurrences non-OK', res.status);
        return;
      }
      let data;
      try {
        data = await res.json();
      } catch (e) {
        console.error('DEBUG: fetchOccurrences invalid JSON');
        return;
      }
      // Ensure month view renders in chronological order regardless of server-side
      // priority sorting. Sort by occurrence_dt ascending with stable tie-breakers.
      let occs = (data && Array.isArray(data.occurrences) ? data.occurrences.slice() : []).sort(function(a, b){
        try {
          // Prefer numeric occ_ts from server to avoid costly Date parsing
          const aTs = (a && a.occ_ts != null) ? Number(a.occ_ts) : (a && a.occurrence_dt ? Date.parse(a.occurrence_dt) : 0);
          const bTs = (b && b.occ_ts != null) ? Number(b.occ_ts) : (b && b.occurrence_dt ? Date.parse(b.occurrence_dt) : 0);
          const dtCmp = aTs - bTs;
          if (dtCmp !== 0) return dtCmp;
          // tie-breaker: by title then by occ_hash for deterministic ordering
          const aTitle = (a && a.title) ? String(a.title) : '';
          const bTitle = (b && b.title) ? String(b.title) : '';
          const tCmp = aTitle.localeCompare(bTitle, undefined, {sensitivity: 'base'});
          if (tCmp !== 0) return tCmp;
          const ah = (a && a.occ_hash) ? String(a.occ_hash) : '';
          const bh = (b && b.occ_hash) ? String(b.occ_hash) : '';
          return ah.localeCompare(bh);
        } catch(e) { return 0; }
      });
      // Apply client-side filtering for "Hide completed" when enabled (default ON)
      try {
        const hideVal = (function(){ try { return localStorage.getItem('cal_hide_completed'); } catch(e){ return null; } })();
        const hideCompleted = (hideVal === null || hideVal === '1');
        if (hideCompleted) {
          occs = occs.filter(function(ev){ return !(ev && ev.completed); });
        }
      } catch(e) { /* ignore storage/filter errors */ }
      // Ensure we always have a UL container to replace
      let container = document.querySelector('.todos-list');
      if (!container) {
        // Create a skeleton UL if none found (defensive)
        const sec = document.querySelector('section.full-bleed') || document.body;
        const ulInit = document.createElement('ul'); ulInit.className = 'todos-list';
        const liInit = document.createElement('li'); liInit.className = 'todo'; liInit.innerHTML = '<div class="todo-content"><div class="todo-main wrap-text"><div class="meta">Loading calendar events...</div></div></div>';
        ulInit.appendChild(liInit);
        sec.appendChild(ulInit);
        container = ulInit;
      }
      const parent = container && container.parentNode; if (!parent) return;
        if (occs && occs.length > 0) {
        // Build a list of occ_hashes for the fetched occurrences
        const newHashes = occs.map(function(ev){ return ev && ev.occ_hash ? String(ev.occ_hash) : ''; });
        // Read current DOM occurrence order (if present) to avoid unnecessary reflows
  const existingHashes = Array.from((parent.querySelectorAll('li.todo[data-hash]')||[])).map(function(el){ return el.getAttribute('data-hash') || ''; });
        // If the order of occ_hashes is identical, avoid full replace; instead update checkbox states and ignored markers
  if (existingHashes.length === newHashes.length && existingHashes.every(function(h, i){ return h === newHashes[i]; })) {
          try {
            occs.forEach(function(ev){
              try {
                const li = parent.querySelector('li.todo[data-hash="' + ev.occ_hash + '"]');
                if (!li) return;
                const chk = li.querySelector('.occ-complete[data-hash="' + ev.occ_hash + '"]');
                if (chk) {
                  // preserve any in-flight user action when present
                  if (!window.__occInFlight || !window.__occInFlight[ev.occ_hash]) {
                    chk.checked = !!ev.completed;
                    // ensure disabled state for phantom occurrences
                    if (ev.phantom) {
                      try { chk.disabled = true; chk.setAttribute('title','Historic completion (read-only)'); chk.setAttribute('data-phantom','1'); } catch(e){}
                    }
                  }
                }
                // update meta/date text for this occurrence row if present
                const metaEl = li.querySelector('.todo .meta, .meta');
                if (metaEl) { metaEl.textContent = (ev.occurrence_date || ev.occurrence_dt) || ''; }
              } catch(e) { /* ignore per-occ update errors */ }
            });
          } catch(e) { /* ignore overall update errors */ }
          // Reveal the existing server-rendered list (we updated checkbox states above)
          try { const existing = parent.querySelector('.todos-list'); if (existing) existing.style.visibility = 'visible'; } catch(e) {}
          return;
        }
        const ul = document.createElement('ul'); ul.className = 'todos-list';
        const frag = document.createDocumentFragment();
        // read global in-flight map if present so we can preserve user actions
        const occInFlight = (window.__occInFlight || {});
        for (const ev of occs) {
          // if a change for this occ_hash is in-flight, prefer the current DOM
          // checkbox state (user action) instead of the server-provided value
          try {
            if (ev && ev.occ_hash && occInFlight[ev.occ_hash]) {
              const existing = document.querySelector(`.occ-complete[data-hash="${ev.occ_hash}"]`);
              if (existing) {
                ev.completed = !!existing.checked;
              }
            }
          } catch (e) { /* ignore DOM lookup failures */ }
          const li = document.createElement('li'); li.className = 'todo'; li.setAttribute('data-hash', ev.occ_hash || '');
          const title = ev.item_type === 'todo' ? `<a href="/html_no_js/todos/${ev.id}">${ev.title}</a>` : ev.item_type === 'list' ? `<a href="/html_no_js/lists/${ev.id}">${ev.title}</a>` : ev.title;
          // Build a left-controls column so checkboxes and ignore buttons sit to the left of the content
          // small icon buttons: single-occurrence ignore and ignore-from-date
          // use data attributes: data-occ for occ_hash, data-todo for the todo/list id
            // prefer server-supplied date-only string when available
            const occDate = (ev.occurrence_date || ev.occurrence_dt);
            let occControls = `<div class="controls-left">
            <input type="checkbox" class="occ-complete" data-hash="${ev.occ_hash}" data-item-type="${ev.item_type || ''}" data-item-id="${ev.id || ''}" data-occ-dt="${occDate || ''}" data-phantom="${ev.phantom ? '1' : ''}" ${ev.completed ? 'checked' : ''} ${ev.phantom ? 'disabled title="Historic completion (read-only)"' : ''} aria-label="mark occurrence complete">
            <button type="button" class="occ-ignore-occ" data-occ="${ev.occ_hash}" title="Ignore in calendar altogether" aria-label="Ignore this occurrence" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">üîï</button>
            <button type="button" class="occ-ignore-from" data-todo="${ev.id}" data-occ-dt="${occDate}" title="Ignore from this date" aria-label="Ignore from this date" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚è≠Ô∏è</button>`;
          if (showIgnored && ev.ignored) {
            // show an unignore control (checkbox or button) when item is ignored
            occControls += ` <button type="button" class="occ-unignore" data-occ="${ev.occ_hash}" data-item-id="${ev.id}" title="Unignore" aria-label="Unignore" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚Ü©Ô∏è</button>`;
          }
          occControls += `</div>`;
          const ignoredStyle = (showIgnored && ev.ignored) ? ' style="opacity:0.6;"' : '';
  const html = `${occControls}\n  <div class="todo-content"${ignoredStyle}>\n    <div class="todo-main wrap-text">\n      <div class=\"wrap-text\" style=\"font-weight:700\">${title}${(showIgnored && ev.ignored) ? ' <span class=\"meta\" style=\"margin-left:0.35rem;\">(ignored)</span>' : ''}</div>\n      <div class=\"meta\">${occDate}</div>\n    </div>\n  </div>\n  `;
          li.innerHTML = html; frag.appendChild(li);
        }
  ul.appendChild(frag);
  parent.replaceChild(ul, container);
  try { ul.style.visibility = 'visible'; } catch(e) {}
      } else {
  const p = document.createElement('p'); p.className = 'meta'; p.textContent = 'No events found for this month.'; parent.replaceChild(p, container);
  try { p.style.visibility = 'visible'; } catch(e) {}
      }
    } catch (e) {
      if (e && (e.name === 'AbortError' || String(e).indexOf('AbortError') !== -1)) {
        // ignore aborted requests
        return;
      }
      console.error('DEBUG: fetchOccurrences error', e);
      // fall through
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    const cb = document.getElementById('include_next7');
    if (cb) {
      cb.checked = (getCookie('include_next7') === '1');
      cb.addEventListener('change', function(){ setCookie('include_next7', cb.checked ? '1' : '0', 365); fetchOccurrencesForCurrentWindow(); });
    }
    const showIg = document.getElementById('show_ignored');
    if (showIg) {
      showIg.checked = (getCookie('show_ignored') === '1');
      showIg.addEventListener('change', function(){ setCookie('show_ignored', showIg.checked ? '1' : '0', 365); fetchOccurrencesForCurrentWindow(); });
    }
    const hideCb = document.getElementById('hide_completed');
    if (hideCb) {
      try {
        const v = localStorage.getItem('cal_hide_completed');
        // Default ON when missing
        hideCb.checked = (v === null || v === '1');
      } catch (e) {
        hideCb.checked = true;
      }
      hideCb.addEventListener('change', function(){
        try { localStorage.setItem('cal_hide_completed', hideCb.checked ? '1' : '0'); } catch (e) {}
        fetchOccurrencesForCurrentWindow();
      });
    }
  // initial load
  fetchOccurrencesForCurrentWindow();
  // emit a Puppeteer-friendly debug event if helper is available
  try{ if (window.__puppeteerDebug && typeof window.__puppeteerDebug.event === 'function') window.__puppeteerDebug.event('calendar-page-init'); }catch(e){ console.debug('PUPPETEER_DEBUG_RENDER_ISSUE', String(e)); }
  });

  // ignore and complete handlers
  document.addEventListener('click', function(e){
    // single-occurrence ignore button
    const igOcc = e.target.closest('.occ-ignore-occ');
    if (igOcc) {
      const occ = igOcc.getAttribute('data-occ'); if (!occ) return;
      const csrf = getCookie('csrf_token') || '';
      const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=occurrence&scope_key=${encodeURIComponent(occ)}`;
      fetch('/ignore/scope', { method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
        .then(async r => { let j=null; try{ j = await r.json(); }catch(e){ j={error:'invalid-json'};} console.log('DEBUG: ignore_response', {status:r.status, body:j}); const el = igOcc.closest('.todo'); if (el) el.style.display='none'; })
        .catch(err => console.error('DEBUG: ignore_error', err));
      return;
    }
    // ignore from this date button
    const igFrom = e.target.closest('.occ-ignore-from');
    if (igFrom) {
      const todo = igFrom.getAttribute('data-todo'); const occdt = igFrom.getAttribute('data-occ-dt'); if (!todo || !occdt) return;
      const csrf = getCookie('csrf_token') || '';
      // from_dt should be ISO; occdt already provided by server in ISO
      const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=todo_from&scope_key=${encodeURIComponent(todo)}&from_dt=${encodeURIComponent(occdt)}`;
      fetch('/ignore/scope', { method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
        .then(async r => { let j=null; try{ j = await r.json(); }catch(e){ j={error:'invalid-json'};} console.log('DEBUG: ignore_from_response', {status:r.status, body:j}); const el = igFrom.closest('.todo'); if (el) el.style.display='none'; })
        .catch(err => console.error('DEBUG: ignore_from_error', err));
      return;
    }
    // unignore button
    const unIg = e.target.closest('.occ-unignore');
    if (unIg) {
      const occ = unIg.getAttribute('data-occ');
      const itemId = unIg.getAttribute('data-item-id');
      const csrf = getCookie('csrf_token') || '';
      if (occ) {
        const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=occurrence&scope_key=${encodeURIComponent(occ)}`;
        fetch('/ignore/unscope', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_occ_error', err));
      } else if (itemId) {
        const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=todo_from&scope_key=${encodeURIComponent(itemId)}`;
        fetch('/ignore/unscope', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_todo_from_error', err));
      }
      return;
    }
    // fall through to other handlers
  });

  document.addEventListener('change', function(e){
  const cb = e.target.closest('.occ-complete'); if (!cb) return; const hash = cb.getAttribute('data-hash'); if (!hash) return;
  // If this checkbox represents a phantom (historic) occurrence, ignore change events
  const isPhantom = cb.getAttribute('data-phantom');
  if (isPhantom) { try { cb.checked = true; } catch(e){} return; }
  const itemType = cb.getAttribute('data-item-type') || '';
  const itemId = cb.getAttribute('data-item-id') || '';
  const occDt = cb.getAttribute('data-occ-dt') || '';
    // simple in-flight and debounce guard to prevent duplicate toggles
    // caused by rapid duplicate events when fetchOccurrencesForCurrentWindow
    // replaces DOM or on initial page refresh. Keyed by occ_hash.
    window.__occInFlight = window.__occInFlight || {};
    window.__occLastProcessed = window.__occLastProcessed || {};
    const now = Date.now();
    // ignore event if a request for this hash is already in-flight
    if (window.__occInFlight[hash]) {
      console.debug('IGNORING duplicate change - in-flight', hash);
      return;
    }
    // ignore if we processed a change for this hash very recently (debounce 800ms)
    const last = window.__occLastProcessed[hash] || 0;
    if (now - last < 800) {
      console.debug('IGNORING duplicate change - debounced', hash, now - last);
      return;
    }
    if (cb.checked) {
  // mark in-flight and disable checkbox to avoid duplicate clicks and optimistic race
  window.__occInFlight[hash] = true;
  cb.disabled = true;
      const csrf = getCookie('csrf_token') || '';
  const body = `_csrf=${encodeURIComponent(csrf)}&hash=${encodeURIComponent(hash)}&item_type=${encodeURIComponent(itemType)}&item_id=${encodeURIComponent(itemId)}&occurrence_dt=${encodeURIComponent(occDt)}`;
      (async () => {
        // Helper to retry once after attempting CSRF refresh
        async function postComplete() {
          const r = await fetch('/occurrence/complete', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' });
          return r;
        }
        let r = await postComplete();
        if (r.status === 403) {
          try {
            // If middleware hinted a refresh or token likely expired, request a refresh and retry once
            await fetch('/csrf/refresh', { method: 'POST', credentials: 'same-origin' });
          } catch (e) { /* ignore */ }
          r = await postComplete();
        }
        let j = null;
        try { j = await r.json(); } catch (e) { j = { error: 'invalid-json' }; }
        console.log('DEBUG: complete_response', { status: r.status, body: j });
        if (!r.ok || (j && typeof j.ok !== 'undefined' && !j.ok)) {
          cb.checked = false;
        } else {
          // If "Hide completed" is enabled, hide the occurrence row immediately
          try {
            const v = localStorage.getItem('cal_hide_completed');
            const hideCompleted = (v === null || v === '1');
            if (hideCompleted) {
              const row = cb.closest('.todo');
              if (row) { row.style.display = 'none'; }
            }
          } catch (e) { /* ignore storage/DOM errors */ }
        }
      })().catch(err => { console.error('DEBUG: complete_error', err); cb.checked = false; })
      .finally(() => { cb.disabled = false; window.__occInFlight[hash] = false; window.__occLastProcessed[hash] = Date.now(); });
    } else {
  // mark in-flight and disable checkbox to avoid duplicate clicks and optimistic race
  window.__occInFlight[hash] = true;
  cb.disabled = true;
      const csrf = getCookie('csrf_token') || '';
  const body = `_csrf=${encodeURIComponent(csrf)}&hash=${encodeURIComponent(hash)}&item_type=${encodeURIComponent(itemType)}&item_id=${encodeURIComponent(itemId)}&occurrence_dt=${encodeURIComponent(occDt)}`;
      (async () => {
        async function postUncomplete() {
          const r = await fetch('/occurrence/uncomplete', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' });
          return r;
        }
        let r = await postUncomplete();
        if (r.status === 403) {
          try { await fetch('/csrf/refresh', { method: 'POST', credentials: 'same-origin' }); } catch (e) {}
          r = await postUncomplete();
        }
        let j = null;
        try { j = await r.json(); } catch (e) { j = { error: 'invalid-json' }; }
        console.log('DEBUG: uncomplete_response', { status: r.status, body: j });
        if (!r.ok || (j && typeof j.ok !== 'undefined' && !j.ok)) {
          cb.checked = true;
        }
      })().catch(err => { console.error('DEBUG: uncomplete_error', err); cb.checked = true; })
      .finally(() => { cb.disabled = false; window.__occInFlight[hash] = false; window.__occLastProcessed[hash] = Date.now(); });
    }
  });
  // Wire include_historic checkbox
  try {
    const histCb = document.getElementById('include_historic');
    if (histCb) {
      histCb.checked = (getCookie('include_historic') === '1');
      histCb.addEventListener('change', function(){
        setCookie('include_historic', histCb.checked ? '1' : '0', 365);
        fetchOccurrencesForCurrentWindow();
      });
    }
  } catch(e) { /* ignore */ }
  </script>

  {% endblock %}

{% endblock %}


