{% extends 'base.html' %}

{% block title %}Calendar - Fast Todo{% endblock %}

{% block content %}
<!-- DEBUG_TEMPLATE_ID: 20250825-1 -->
  <style>
    /* remove top gap so toolbar sits flush to the top on calendar page */
    body { margin-top: 0 !important; }
    header { margin-top: 0 !important; }
    /* hide server-rendered occurrences when JS is present; keep layout space to avoid reflow */
    .ft-js .todos-list { visibility: hidden; }
    /* calendar page: do not expand full-bleed container beyond 100% to avoid rounding-induced clipping */
    section.full-bleed.calendar-bleed { width: 100% !important; max-width: 100% !important; }
  </style>
  <script>
    // Mark page as JS-enabled as early as possible to avoid showing a mismatched
    // server-rendered list briefly before the client replaces it.
    try { document.documentElement.classList.add('ft-js'); } catch (e) {}
  </script>
  <section class="full-bleed calendar-bleed">
    <div style="display:flex; align-items:center; gap:0.5rem;">
      <h2>Calendar - {{ year }}-{{ '%02d'|format(month) }}</h2>
      <div style="margin-left:auto">
        <a class="button" href="/html_no_js/calendar?year={{ prev_year }}&month={{ prev_month }}">‚óÄ Prev</a>
        <a class="button" href="/html_no_js/calendar?year={{ next_year }}&month={{ next_month }}">Next ‚ñ∂</a>
      </div>
    </div>
    <div style="margin-top:0.5rem">
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="show_ignored"> Show ignored
      </label>
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-left:0.75rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="hide_completed"> Hide completed
      </label>
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-left:0.75rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="include_historic"> Include historic (show phantom completions)
      </label>
      {% if occurrences_sorted and occurrences_sorted|length > 0 %}
      <ul class="todos-list">
      {% for ev in occurrences_sorted %}
        <li class="todo" data-occ-id="{{ ev.occ_id or ev.occ_hash or '' }}">
            <div class="controls-left">
            <input type="checkbox" class="occ-complete" data-occ-id="{{ ev.occ_id or ev.occ_hash or '' }}" data-hash="{{ ev.occ_hash or '' }}" data-item-type="{{ ev.item_type }}" data-item-id="{{ ev.id }}" data-occ-dt="{{ ev.occurrence_dt }}" data-phantom="{{ '1' if ev.phantom else '' }}" {% if ev.completed %}checked{% endif %} {% if ev.phantom %}disabled title="Historic completion (read-only)"{% endif %} aria-label="mark occurrence complete">
            <button type="button" class="occ-ignore-occ" data-occ="{{ ev.occ_id or ev.occ_hash or '' }}" data-item-id="{{ ev.id }}" title="Ignore in calendar altogether." aria-label="Ignore this todo from calendar" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">üîï</button>
            <button type="button" class="occ-ignore-from" data-todo="{{ ev.id }}" data-occ-dt="{{ ev.occurrence_dt }}" title="Ignore from this date" aria-label="Ignore from this date" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚è≠Ô∏è</button>
          </div>
          <div class="todo-content">
            <div class="todo-main wrap-text">
              <div class="wrap-text" style="font-weight:700">
                {% if ev.item_type == 'todo' %}
                  <a href="/html_no_js/todos/{{ ev.id }}">{{ ev.title }}</a>
                {% elif ev.item_type == 'list' %}
                  <a href="/html_no_js/lists/{{ ev.id }}">{{ ev.title }}</a>
                {% else %}
                  {{ ev.title }}
                {% endif %}
              </div>
              <div class="meta">{{ ev.occurrence_date or ev.occurrence_dt }}</div>
            </div>
          </div>
        </li>
      {% endfor %}
      </ul>
      {% else %}
      <!-- Minimal skeleton list so JS can replace in-place -->
      <ul class="todos-list">
        <li class="todo">
          <div class="todo-content">
            <div class="todo-main wrap-text">
              <div class="meta">Loading calendar events...</div>
            </div>
          </div>
        </li>
      </ul>
      {% endif %}
    </div>
  </section>
  {% block scripts %}{{ super() }}

  <script>
  console.log('DEBUG: calendar page script loaded');
  // Abort controller for deduplicating fetches when users toggle options rapidly
  // Use var instead of let to allow redeclaration if script runs multiple times
  var __occFetchController = null;
  function setCookie(name, value, days) {
    let expires = '';
    if (days) { const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); expires = '; expires=' + d.toUTCString(); }
    document.cookie = name + '=' + (value || '')  + expires + '; path=/';
  }
  function getCookie(name) { const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)'); return v ? v.pop() : ''; }

  // Fetch occurrences for the current calendar window and replace the list
  async function fetchOccurrencesForCurrentWindow() {
    try {
      // Abort any in-flight request before starting a new one
      try { if (__occFetchController) { __occFetchController.abort(); } } catch(e) {}
      __occFetchController = (typeof AbortController !== 'undefined') ? new AbortController() : null;
      // no watchdog timer; rendering will proceed normally

      const params = new URLSearchParams(window.location.search);
      const year = parseInt(params.get('year') || '{{ year }}', 10);
      const month = parseInt(params.get('month') || '{{ month }}', 10);
      const start = new Date(Date.UTC(year, month-1, 1, 0,0,0));
      const lastDay = new Date(Date.UTC(year, month, 0)).getUTCDate();
      let end;
  const includeNext7 = getCookie('include_next7') === '1';
  const includeHistoric = getCookie('include_historic') === '1';
      if (includeNext7) {
        end = new Date(Date.UTC(year, month, 7, 23,59,59)).toISOString();
      } else {
        end = new Date(Date.UTC(year, month-1, lastDay, 23,59,59)).toISOString();
      }
      
      const startIso = start.toISOString();
      const showIgnored = getCookie('show_ignored') === '1';
      const maxTotal = 3000; // UI safety cap to limit payload size
  const q = `/calendar/occurrences?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(end)}&include_ignored=${showIgnored ? '1' : '0'}&include_historic=${includeHistoric ? '1' : '0'}&max_total=${maxTotal}`;
      const res = await fetch(q, { credentials: 'same-origin', signal: __occFetchController ? __occFetchController.signal : undefined });
      if (!res.ok) {
        console.error('DEBUG: fetchOccurrences non-OK', res.status);
        return;
      }
      let data;
      try {
        data = await res.json();
      } catch (e) {
        console.error('DEBUG: fetchOccurrences invalid JSON');
        return;
      }
      // Ensure month view renders in chronological order regardless of server-side
      // priority sorting. Sort by occurrence_dt ascending with stable tie-breakers.
      let occs = (data && Array.isArray(data.occurrences) ? data.occurrences.slice() : []).sort(function(a, b){
        try {
          // Prefer numeric occ_ts from server to avoid costly Date parsing
          const aTs = (a && a.occ_ts != null) ? Number(a.occ_ts) : (a && a.occurrence_dt ? Date.parse(a.occurrence_dt) : 0);
          const bTs = (b && b.occ_ts != null) ? Number(b.occ_ts) : (b && b.occurrence_dt ? Date.parse(b.occurrence_dt) : 0);
          const dtCmp = aTs - bTs;
          if (dtCmp !== 0) return dtCmp;
          // tie-breaker: by title then by occ_hash for deterministic ordering
          const aTitle = (a && a.title) ? String(a.title) : '';
          const bTitle = (b && b.title) ? String(b.title) : '';
          const tCmp = aTitle.localeCompare(bTitle, undefined, {sensitivity: 'base'});
          if (tCmp !== 0) return tCmp;
          // Phase 2: Use occ_id for stable sorting
          const aId = (a && (a.occ_id || a.occ_hash)) ? String(a.occ_id || a.occ_hash) : '';
          const bId = (b && (b.occ_id || b.occ_hash)) ? String(b.occ_id || b.occ_hash) : '';
          return aId.localeCompare(bId);
        } catch(e) { return 0; }
      });
      // Apply client-side filtering for "Hide completed" when enabled (default ON)
      try {
        const hideVal = (function(){ try { return localStorage.getItem('cal_hide_completed'); } catch(e){ return null; } })();
        const hideCompleted = (hideVal === null || hideVal === '1');
        if (hideCompleted) {
          occs = occs.filter(function(ev){ return !(ev && ev.completed); });
        }
      } catch(e) { /* ignore storage/filter errors */ }
      // Ensure we always have a UL container to replace
      let container = document.querySelector('.todos-list');
      if (!container) {
        // Create a skeleton UL if none found (defensive)
        const sec = document.querySelector('section.full-bleed') || document.body;
        const ulInit = document.createElement('ul'); ulInit.className = 'todos-list';
        const liInit = document.createElement('li'); liInit.className = 'todo'; liInit.innerHTML = '<div class="todo-content"><div class="todo-main wrap-text"><div class="meta">Loading calendar events...</div></div></div>';
        ulInit.appendChild(liInit);
        sec.appendChild(ulInit);
        container = ulInit;
      }
      const parent = container && container.parentNode; if (!parent) return;
        if (occs && occs.length > 0) {
        // Phase 2: Build list of occ_ids (or fallback to hash for old data)
        const newIds = occs.map(function(ev){ return ev && (ev.occ_id || ev.occ_hash) ? String(ev.occ_id || ev.occ_hash) : ''; });
        // Read current DOM occurrence order (if present) to avoid unnecessary reflows
  const existingIds = Array.from((parent.querySelectorAll('li.todo[data-occ-id]')||[])).map(function(el){ return el.getAttribute('data-occ-id') || el.getAttribute('data-hash') || ''; });
        // If the order of occ_ids is identical, avoid full replace; instead update checkbox states and ignored markers
  if (existingIds.length === newIds.length && existingIds.every(function(h, i){ return h === newIds[i]; })) {
          try {
            occs.forEach(function(ev){
              try {
                const occId = ev.occ_id || ev.occ_hash || '';
                const li = parent.querySelector('li.todo[data-occ-id="' + occId + '"]');
                if (!li) return;
                const chk = li.querySelector('.occ-complete[data-occ-id="' + occId + '"]');
                if (chk) {
                  // preserve any in-flight user action when present
                  if (!window.__occInFlight || !window.__occInFlight[occId]) {
                    chk.checked = !!ev.completed;
                    // ensure disabled state for phantom occurrences
                    if (ev.phantom) {
                      try { chk.disabled = true; chk.setAttribute('title','Historic completion (read-only)'); chk.setAttribute('data-phantom','1'); } catch(e){}
                    }
                  }
                }
                // update meta/date text for this occurrence row if present
                const metaEl = li.querySelector('.todo .meta, .meta');
                if (metaEl) { metaEl.textContent = (ev.occurrence_date || ev.occurrence_dt) || ''; }
              } catch(e) { /* ignore per-occ update errors */ }
            });
          } catch(e) { /* ignore overall update errors */ }
          // Reveal the existing server-rendered list (we updated checkbox states above)
          try { const existing = parent.querySelector('.todos-list'); if (existing) existing.style.visibility = 'visible'; } catch(e) {}
          return;
        }
        const ul = document.createElement('ul'); ul.className = 'todos-list';
        const frag = document.createDocumentFragment();
        // read global in-flight map if present so we can preserve user actions
        const occInFlight = (window.__occInFlight || {});
        for (const ev of occs) {
          // Phase 2: Use occ_id for in-flight check
          const occId = ev.occ_id || ev.occ_hash || `${ev.item_type}:${ev.id}:${ev.occurrence_dt}`;
          // if a change for this occurrence is in-flight, prefer the current DOM
          // checkbox state (user action) instead of the server-provided value
          try {
            if (occId && occInFlight[occId]) {
              const existing = document.querySelector(`.occ-complete[data-occ-id="${occId}"]`);
              if (existing) {
                ev.completed = !!existing.checked;
              }
            }
          } catch (e) { /* ignore DOM lookup failures */ }
          const li = document.createElement('li'); li.className = 'todo'; li.setAttribute('data-occ-id', occId || '');
          const title = ev.item_type === 'todo' ? `<a href="/html_no_js/todos/${ev.id}">${ev.title}</a>` : ev.item_type === 'list' ? `<a href="/html_no_js/lists/${ev.id}">${ev.title}</a>` : ev.title;
          // Build a left-controls column so checkboxes and ignore buttons sit to the left of the content
          // small icon buttons: single-occurrence ignore and ignore-from-date
          // use data attributes: data-occ for occ_id, data-todo for the todo/list id
            // prefer server-supplied date-only string when available
            const occDate = (ev.occurrence_date || ev.occurrence_dt);
            // Phase 2: occId already declared above
            let occControls = `<div class="controls-left">
            <input type="checkbox" class="occ-complete" data-occ-id="${occId}" data-hash="${ev.occ_hash || ''}" data-item-type="${ev.item_type || ''}" data-item-id="${ev.id || ''}" data-occ-dt="${occDate || ''}" data-phantom="${ev.phantom ? '1' : ''}" ${ev.completed ? 'checked' : ''} ${ev.phantom ? 'disabled title="Historic completion (read-only)"' : ''} aria-label="mark occurrence complete">
            <button type="button" class="occ-ignore-occ" data-occ="${occId}" data-item-id="${ev.id || ''}" title="Ignore in calendar altogether" aria-label="Ignore this todo from calendar" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">üîï</button>
            <button type="button" class="occ-ignore-from" data-todo="${ev.id}" data-occ-dt="${occDate}" title="Ignore from this date" aria-label="Ignore from this date" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚è≠Ô∏è</button>`;
          if (showIgnored && ev.ignored) {
            // show an unignore control (checkbox or button) when item is ignored
            // Check if ignored due to calendar_ignored flag (vs other scope types)
            const isCalIgnored = ev.ignored_scopes && ev.ignored_scopes.includes('calendar_ignored') ? '1' : '0';
            occControls += ` <button type="button" class="occ-unignore" data-occ="${occId}" data-item-id="${ev.id}" data-calendar-ignored="${isCalIgnored}" title="Unignore" aria-label="Unignore" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚Ü©Ô∏è</button>`;
          }
          occControls += `</div>`;
          const ignoredStyle = (showIgnored && ev.ignored) ? ' style="opacity:0.6;"' : '';
  const html = `${occControls}\n  <div class="todo-content"${ignoredStyle}>\n    <div class="todo-main wrap-text">\n      <div class=\"wrap-text\" style=\"font-weight:700\">${title}${(showIgnored && ev.ignored) ? ' <span class=\"meta\" style=\"margin-left:0.35rem;\">(ignored)</span>' : ''}</div>\n      <div class=\"meta\">${occDate}</div>\n    </div>\n  </div>\n  `;
          li.innerHTML = html; frag.appendChild(li);
        }
  ul.appendChild(frag);
  parent.replaceChild(ul, container);
  try { ul.style.visibility = 'visible'; } catch(e) {}
      } else {
  const p = document.createElement('p'); p.className = 'meta'; p.textContent = 'No events found for this month.'; parent.replaceChild(p, container);
  try { p.style.visibility = 'visible'; } catch(e) {}
      }
    } catch (e) {
      if (e && (e.name === 'AbortError' || String(e).indexOf('AbortError') !== -1)) {
        // ignore aborted requests
        return;
      }
      console.error('DEBUG: fetchOccurrences error', e);
      // fall through
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    const cb = document.getElementById('include_next7');
    if (cb) {
      cb.checked = (getCookie('include_next7') === '1');
      cb.addEventListener('change', function(){ setCookie('include_next7', cb.checked ? '1' : '0', 365); fetchOccurrencesForCurrentWindow(); });
    }
    const showIg = document.getElementById('show_ignored');
    if (showIg) {
      showIg.checked = (getCookie('show_ignored') === '1');
      showIg.addEventListener('change', function(){ setCookie('show_ignored', showIg.checked ? '1' : '0', 365); fetchOccurrencesForCurrentWindow(); });
    }
    const hideCb = document.getElementById('hide_completed');
    if (hideCb) {
      try {
        const v = localStorage.getItem('cal_hide_completed');
        // Default ON when missing
        hideCb.checked = (v === null || v === '1');
      } catch (e) {
        hideCb.checked = true;
      }
      hideCb.addEventListener('change', function(){
        try { localStorage.setItem('cal_hide_completed', hideCb.checked ? '1' : '0'); } catch (e) {}
        fetchOccurrencesForCurrentWindow();
      });
    }
    // If the URL has no year/month params, prefer the user's local timezone month
    try {
      const params = new URLSearchParams(window.location.search);
      if (!params.get('year') && !params.get('month')) {
        const nowLocal = new Date();
        const yLocal = nowLocal.getFullYear();
        const mLocal = nowLocal.getMonth() + 1;
        // Update the URL without reloading so subsequent logic uses these params
        const newUrl = `${location.pathname}?year=${yLocal}&month=${mLocal}`;
        try { history.replaceState(null, '', newUrl); } catch (e) {}
        // Update header text
        try {
          const h2 = document.querySelector('section.full-bleed h2');
          if (h2) { h2.textContent = `Calendar - ${yLocal}-${String(mLocal).padStart(2,'0')}`; }
        } catch (e) {}
        // Update prev/next links in the nav
        try {
          const prevMonth = (mLocal - 1) < 1 ? 12 : (mLocal - 1);
          const prevYear = (mLocal - 1) < 1 ? (yLocal - 1) : yLocal;
          const nextMonth = (mLocal + 1) > 12 ? 1 : (mLocal + 1);
          const nextYear = (mLocal + 1) > 12 ? (yLocal + 1) : yLocal;
          const anchors = document.querySelectorAll('section.full-bleed a.button');
          if (anchors && anchors.length >= 2) {
            anchors[0].setAttribute('href', `/html_no_js/calendar?year=${prevYear}&month=${prevMonth}`);
            anchors[1].setAttribute('href', `/html_no_js/calendar?year=${nextYear}&month=${nextMonth}`);
          }
        } catch (e) {}
      }
    } catch (e) { /* ignore URL parsing errors */ }
  // initial load
  fetchOccurrencesForCurrentWindow();
  // emit a Puppeteer-friendly debug event if helper is available
  try{ if (window.__puppeteerDebug && typeof window.__puppeteerDebug.event === 'function') window.__puppeteerDebug.event('calendar-page-init'); }catch(e){ console.debug('PUPPETEER_DEBUG_RENDER_ISSUE', String(e)); }
  });

  // ignore and complete handlers
  document.addEventListener('click', function(e){
    // ignore todo from calendar altogether (all occurrences)
    const igOcc = e.target.closest('.occ-ignore-occ');
    if (igOcc) {
      // Phase 2: Use item_id from occurrence metadata to set calendar_ignored flag on todo
      const itemId = igOcc.getAttribute('data-item-id');
      if (!itemId) return;
      const csrf = getCookie('csrf_token') || '';
      const body = `_csrf=${encodeURIComponent(csrf)}&calendar_ignored=1`;
      fetch(`/html_no_js/todos/${itemId}/calendar_ignored`, { method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
        .then(async r => { let j=null; try{ j = await r.json(); }catch(e){ j={error:'invalid-json'};} console.log('DEBUG: calendar_ignore_response', {status:r.status, body:j}); fetchOccurrencesForCurrentWindow(); })
        .catch(err => console.error('DEBUG: calendar_ignore_error', err));
      return;
    }
    // ignore from this date button
    const igFrom = e.target.closest('.occ-ignore-from');
    if (igFrom) {
      const todo = igFrom.getAttribute('data-todo'); const occdt = igFrom.getAttribute('data-occ-dt'); if (!todo || !occdt) return;
      const csrf = getCookie('csrf_token') || '';
      // from_dt should be ISO; occdt already provided by server in ISO
      const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=todo_from&scope_key=${encodeURIComponent(todo)}&from_dt=${encodeURIComponent(occdt)}`;
      fetch('/ignore/scope', { method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
        .then(async r => { let j=null; try{ j = await r.json(); }catch(e){ j={error:'invalid-json'};} console.log('DEBUG: ignore_from_response', {status:r.status, body:j}); const el = igFrom.closest('.todo'); if (el) el.style.display='none'; })
        .catch(err => console.error('DEBUG: ignore_from_error', err));
      return;
    }
    // unignore button (handles both scope-based ignores and calendar_ignored flag)
    const unIg = e.target.closest('.occ-unignore');
    if (unIg) {
      const occ = unIg.getAttribute('data-occ');
      const itemId = unIg.getAttribute('data-item-id');
      const isCalendarIgnored = unIg.getAttribute('data-calendar-ignored') === '1';
      const csrf = getCookie('csrf_token') || '';
      
      if (isCalendarIgnored && itemId) {
        // Unset calendar_ignored flag on the todo
        const body = `_csrf=${encodeURIComponent(csrf)}&calendar_ignored=0`;
        fetch(`/html_no_js/todos/${itemId}/calendar_ignored`, { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_calendar_error', err));
      } else if (occ) {
        // Legacy: unignore specific occurrence scope
        const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=occurrence&scope_key=${encodeURIComponent(occ)}`;
        fetch('/ignore/unscope', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_occ_error', err));
      } else if (itemId) {
        // Unignore todo_from scope
        const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=todo_from&scope_key=${encodeURIComponent(itemId)}`;
        fetch('/ignore/unscope', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_todo_from_error', err));
      }
      return;
    }
    // fall through to other handlers
  });

  document.addEventListener('change', function(e){
  const cb = e.target.closest('.occ-complete'); if (!cb) return;
  // Phase 2: Use metadata as primary identifier (hash optional for backward compat)
  const itemType = cb.getAttribute('data-item-type') || '';
  const itemId = cb.getAttribute('data-item-id') || '';
  const occDt = cb.getAttribute('data-occ-dt') || '';
  const occId = cb.getAttribute('data-occ-id') || `${itemType}:${itemId}:${occDt}`;
  if (!itemType || !itemId || !occDt) { console.debug('missing metadata'); return; }
  // If this checkbox represents a phantom (historic) occurrence, ignore change events
  const isPhantom = cb.getAttribute('data-phantom');
  if (isPhantom) { try { cb.checked = true; } catch(e){} return; }
    // simple in-flight and debounce guard to prevent duplicate toggles
    // Phase 2: Key by occ_id instead of hash
    window.__occInFlight = window.__occInFlight || {};
    window.__occLastProcessed = window.__occLastProcessed || {};
    const now = Date.now();
    // ignore event if a request for this occurrence is already in-flight
    if (window.__occInFlight[occId]) {
      console.debug('IGNORING duplicate change - in-flight', occId);
      return;
    }
    // ignore if we processed a change for this occurrence very recently (debounce 800ms)
    const last = window.__occLastProcessed[occId] || 0;
    if (now - last < 800) {
      console.debug('IGNORING duplicate change - debounced', occId, now - last);
      return;
    }
    if (cb.checked) {
  // mark in-flight and disable checkbox to avoid duplicate clicks and optimistic race
  window.__occInFlight[occId] = true;
  cb.disabled = true;
      const csrf = getCookie('csrf_token') || '';
  // Phase 2: Send only metadata, no hash needed
  const body = `_csrf=${encodeURIComponent(csrf)}&item_type=${encodeURIComponent(itemType)}&item_id=${encodeURIComponent(itemId)}&occurrence_dt=${encodeURIComponent(occDt)}`;
      (async () => {
        // Helper to retry once after attempting CSRF refresh
        async function postComplete() {
          const r = await fetch('/occurrence/complete', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' });
          return r;
        }
        let r = await postComplete();
        if (r.status === 403) {
          try {
            // If middleware hinted a refresh or token likely expired, request a refresh and retry once
            await fetch('/csrf/refresh', { method: 'POST', credentials: 'same-origin' });
          } catch (e) { /* ignore */ }
          r = await postComplete();
        }
        let j = null;
        try { j = await r.json(); } catch (e) { j = { error: 'invalid-json' }; }
        console.log('DEBUG: complete_response', { status: r.status, body: j });
        if (!r.ok || (j && typeof j.ok !== 'undefined' && !j.ok)) {
          cb.checked = false;
        } else {
          // If "Hide completed" is enabled, hide the occurrence row immediately
          try {
            const v = localStorage.getItem('cal_hide_completed');
            const hideCompleted = (v === null || v === '1');
            if (hideCompleted) {
              const row = cb.closest('.todo');
              if (row) { row.style.display = 'none'; }
            }
          } catch (e) { /* ignore storage/DOM errors */ }
        }
      })().catch(err => { console.error('DEBUG: complete_error', err); cb.checked = false; })
      .finally(() => { cb.disabled = false; window.__occInFlight[occId] = false; window.__occLastProcessed[occId] = Date.now(); });
    } else {
  // mark in-flight and disable checkbox to avoid duplicate clicks and optimistic race
  window.__occInFlight[occId] = true;
  cb.disabled = true;
      const csrf = getCookie('csrf_token') || '';
  // Phase 2: Send only metadata, no hash needed
  const body = `_csrf=${encodeURIComponent(csrf)}&item_type=${encodeURIComponent(itemType)}&item_id=${encodeURIComponent(itemId)}&occurrence_dt=${encodeURIComponent(occDt)}`;
      (async () => {
        async function postUncomplete() {
          const r = await fetch('/occurrence/uncomplete', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' });
          return r;
        }
        let r = await postUncomplete();
        if (r.status === 403) {
          try { await fetch('/csrf/refresh', { method: 'POST', credentials: 'same-origin' }); } catch (e) {}
          r = await postUncomplete();
        }
        let j = null;
        try { j = await r.json(); } catch (e) { j = { error: 'invalid-json' }; }
        console.log('DEBUG: uncomplete_response', { status: r.status, body: j });
        if (!r.ok || (j && typeof j.ok !== 'undefined' && !j.ok)) {
          cb.checked = true;
        }
      })().catch(err => { console.error('DEBUG: uncomplete_error', err); cb.checked = true; })
      .finally(() => { cb.disabled = false; window.__occInFlight[occId] = false; window.__occLastProcessed[occId] = Date.now(); });
    }
  });
  // Wire include_historic checkbox
  try {
    const histCb = document.getElementById('include_historic');
    if (histCb) {
      histCb.checked = (getCookie('include_historic') === '1');
      histCb.addEventListener('change', function(){
        setCookie('include_historic', histCb.checked ? '1' : '0', 365);
        fetchOccurrencesForCurrentWindow();
      });
    }
  } catch(e) { /* ignore */ }
  </script>

  {% endblock %}

{% endblock %}


