{% extends 'base.html' %}

{% block title %}Calendar - Fast Todo{% endblock %}

{% block content %}
<!-- DEBUG_TEMPLATE_ID: 20250825-1 -->
  <style>
    /* remove top gap so toolbar sits flush to the top on calendar page */
    body { margin-top: 0 !important; }
    header { margin-top: 0 !important; }
    /* hide server-rendered occurrences when JS is present; keep layout space to avoid reflow */
    .ft-js .todos-list.full-bleed { visibility: hidden; }
  </style>
  <script>
    // Mark page as JS-enabled as early as possible to avoid showing a mismatched
    // server-rendered list briefly before the client replaces it.
    try { document.documentElement.classList.add('ft-js'); } catch (e) {}
  </script>
  <section class="full-bleed">
    <div style="display:flex; align-items:center; gap:0.5rem;">
      <h2>Calendar - {{ year }}-{{ '%02d'|format(month) }}</h2>
      <div style="margin-left:auto">
        <a class="button" href="/html_no_js/calendar?year={{ prev_year }}&month={{ prev_month }}">‚óÄ Prev</a>
        <a class="button" href="/html_no_js/calendar?year={{ next_year }}&month={{ next_month }}">Next ‚ñ∂</a>
      </div>
    </div>
    <div style="margin-top:0.5rem">
      <label style="display:inline-flex; align-items:center; gap:0.35rem; margin-bottom:0.5rem;">
        <input type="checkbox" id="show_ignored"> Show ignored
      </label>
      {% if occurrences_sorted and occurrences_sorted|length > 0 %}
      <ul class="todos-list full-bleed">
      {% for ev in occurrences_sorted %}
        <li class="todo">
          <div class="controls-left">
            <input type="checkbox" class="occ-complete" data-hash="{{ ev.occ_hash }}" {% if ev.completed %}checked{% endif %} aria-label="mark occurrence complete">
            <button type="button" class="occ-ignore-occ" data-occ="{{ ev.occ_hash }}" title="Ignore in calendar altogether." aria-label="Ignore this occurrence" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">üîï</button>
            <button type="button" class="occ-ignore-from" data-todo="{{ ev.id }}" data-occ-dt="{{ ev.occurrence_dt }}" title="Ignore from this date" aria-label="Ignore from this date" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚è≠Ô∏è</button>
          </div>
          <div class="todo-content">
            <div class="todo-main wrap-text">
              <div style="font-weight:700">
                {% if ev.item_type == 'todo' %}
                  <a href="/html_no_js/todos/{{ ev.id }}">{{ ev.title }}</a>
                {% elif ev.item_type == 'list' %}
                  <a href="/html_no_js/lists/{{ ev.id }}">{{ ev.title }}</a>
                {% else %}
                  {{ ev.title }}
                {% endif %}
              </div>
              <div class="meta">{{ ev.occurrence_date or ev.occurrence_dt }}</div>
            </div>
          </div>
        </li>
      {% endfor %}
      </ul>
      {% else %}
      <!-- Minimal skeleton list so JS can replace in-place -->
      <ul class="todos-list full-bleed">
        <li class="todo">
          <div class="todo-content">
            <div class="todo-main wrap-text">
              <div class="meta">Loading calendar events...</div>
            </div>
          </div>
        </li>
      </ul>
      {% endif %}
    </div>
  </section>
  {% block scripts %}{{ super() }}

  <script>
  console.log('DEBUG: calendar page script loaded');
  function setCookie(name, value, days) {
    let expires = '';
    if (days) { const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); expires = '; expires=' + d.toUTCString(); }
    document.cookie = name + '=' + (value || '')  + expires + '; path=/';
  }
  function getCookie(name) { const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)'); return v ? v.pop() : ''; }

  // Fetch occurrences for the current calendar window and replace the list
  async function fetchOccurrencesForCurrentWindow() {
    try {
      const params = new URLSearchParams(window.location.search);
      const year = parseInt(params.get('year') || '{{ year }}', 10);
      const month = parseInt(params.get('month') || '{{ month }}', 10);
      const start = new Date(Date.UTC(year, month-1, 1, 0,0,0));
      const lastDay = new Date(Date.UTC(year, month, 0)).getUTCDate();
      let end;
      const includeNext7 = getCookie('include_next7') === '1';
      if (includeNext7) {
        end = new Date(Date.UTC(year, month, 7, 23,59,59)).toISOString();
      } else {
        end = new Date(Date.UTC(year, month-1, lastDay, 23,59,59)).toISOString();
      }
      const startIso = start.toISOString();
      const showIgnored = getCookie('show_ignored') === '1';
      const res = await fetch(`/calendar/occurrences?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(end)}&include_ignored=${showIgnored ? '1' : '0'}`, { credentials: 'same-origin' });
      const data = await res.json();
      // Ensure month view renders in chronological order regardless of server-side
      // priority sorting. Sort by occurrence_dt ascending with stable tie-breakers.
      const occs = (data && Array.isArray(data.occurrences) ? data.occurrences.slice() : []).sort(function(a, b){
        try {
          const ad = a && a.occurrence_dt ? new Date(a.occurrence_dt) : new Date(0);
          const bd = b && b.occurrence_dt ? new Date(b.occurrence_dt) : new Date(0);
          const dtCmp = ad - bd;
          if (dtCmp !== 0) return dtCmp;
          // tie-breaker: by title then by occ_hash for deterministic ordering
          const at = (a && a.title) ? String(a.title) : '';
          const bt = (b && b.title) ? String(b.title) : '';
          const tCmp = at.localeCompare(bt, undefined, {sensitivity: 'base'});
          if (tCmp !== 0) return tCmp;
          const ah = (a && a.occ_hash) ? String(a.occ_hash) : '';
          const bh = (b && b.occ_hash) ? String(b.occ_hash) : '';
          return ah.localeCompare(bh);
        } catch(e) { return 0; }
      });
      const container = document.querySelector('.todos-list.full-bleed') || document.querySelector('p.meta');
      const parent = container && container.parentNode; if (!parent) return;
        if (occs && occs.length > 0) {
        // Build a list of occ_hashes for the fetched occurrences
        const newHashes = occs.map(function(ev){ return ev && ev.occ_hash ? String(ev.occ_hash) : ''; });
        // Read current DOM occurrence order (if present) to avoid unnecessary reflows
        const existingHashes = Array.from((parent.querySelectorAll('.occ-complete')||[])).map(function(el){ return el.getAttribute('data-hash') || ''; });
        // If the order of occ_hashes is identical, avoid full replace; instead update checkbox states and ignored markers
  if (existingHashes.length === newHashes.length && existingHashes.every(function(h, i){ return h === newHashes[i]; })) {
          try {
            occs.forEach(function(ev){
              try {
                const chk = parent.querySelector('.occ-complete[data-hash="' + ev.occ_hash + '"]');
                if (chk) {
                  // preserve any in-flight user action when present
                  if (!window.__occInFlight || !window.__occInFlight[ev.occ_hash]) {
                    chk.checked = !!ev.completed;
                  }
                }
                // update meta/date text for this occurrence row if present
                const row = parent.querySelector('.todo .meta:contains("' + (ev.occurrence_date || ev.occurrence_dt) + '")');
                // best-effort: skip complex DOM updates to avoid layout thrash
              } catch(e) { /* ignore per-occ update errors */ }
            });
          } catch(e) { /* ignore overall update errors */ }
          // Reveal the existing server-rendered list (we updated checkbox states above)
          try { const existing = parent.querySelector('.todos-list.full-bleed'); if (existing) existing.style.visibility = 'visible'; } catch(e) {}
          return;
        }
        const ul = document.createElement('ul'); ul.className = 'todos-list full-bleed';
        // read global in-flight map if present so we can preserve user actions
        const occInFlight = (window.__occInFlight || {});
        for (const ev of occs) {
          // if a change for this occ_hash is in-flight, prefer the current DOM
          // checkbox state (user action) instead of the server-provided value
          try {
            if (ev && ev.occ_hash && occInFlight[ev.occ_hash]) {
              const existing = document.querySelector(`.occ-complete[data-hash="${ev.occ_hash}"]`);
              if (existing) {
                ev.completed = !!existing.checked;
              }
            }
          } catch (e) { /* ignore DOM lookup failures */ }
          const li = document.createElement('li'); li.className = 'todo';
          const title = ev.item_type === 'todo' ? `<a href="/html_no_js/todos/${ev.id}">${ev.title}</a>` : ev.item_type === 'list' ? `<a href="/html_no_js/lists/${ev.id}">${ev.title}</a>` : ev.title;
          // Build a left-controls column so checkboxes and ignore buttons sit to the left of the content
          // small icon buttons: single-occurrence ignore and ignore-from-date
          // use data attributes: data-occ for occ_hash, data-todo for the todo/list id
            // prefer server-supplied date-only string when available
            const occDate = (ev.occurrence_date || ev.occurrence_dt);
            let occControls = `<div class="controls-left">
            <input type="checkbox" class="occ-complete" data-hash="${ev.occ_hash}" ${ev.completed ? 'checked' : ''} aria-label="mark occurrence complete">
            <button type="button" class="occ-ignore-occ" data-occ="${ev.occ_hash}" title="Ignore in calendar altogether" aria-label="Ignore this occurrence" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">üîï</button>
            <button type="button" class="occ-ignore-from" data-todo="${ev.id}" data-occ-dt="${occDate}" title="Ignore from this date" aria-label="Ignore from this date" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚è≠Ô∏è</button>`;
          if (showIgnored && ev.ignored) {
            // show an unignore control (checkbox or button) when item is ignored
            occControls += ` <button type="button" class="occ-unignore" data-occ="${ev.occ_hash}" data-item-id="${ev.id}" title="Unignore" aria-label="Unignore" style="margin-left:0.25rem;padding:0.1rem 0.25rem;font-size:0.9rem;">‚Ü©Ô∏è</button>`;
          }
          occControls += `</div>`;
          const ignoredStyle = (showIgnored && ev.ignored) ? ' style="opacity:0.6;"' : '';
      const html = `${occControls}\n  <div class="todo-content"${ignoredStyle}>\n    <div class="todo-main wrap-text">\n      <div style="font-weight:700">${title}${(showIgnored && ev.ignored) ? ' <span class="meta" style="margin-left:0.35rem;">(ignored)</span>' : ''}</div>\n      <div class="meta">${occDate}</div>\n    </div>\n  </div>\n  `;
          li.innerHTML = html; ul.appendChild(li);
        }
  parent.replaceChild(ul, container);
  try { ul.style.visibility = 'visible'; } catch(e) {}
      } else {
  const p = document.createElement('p'); p.className = 'meta'; p.textContent = 'No events found for this month.'; parent.replaceChild(p, container);
  try { p.style.visibility = 'visible'; } catch(e) {}
      }
    } catch (e) { console.error('DEBUG: fetchOccurrences error', e); }
  }

  document.addEventListener('DOMContentLoaded', function(){
    const cb = document.getElementById('include_next7');
    if (cb) {
      cb.checked = (getCookie('include_next7') === '1');
      cb.addEventListener('change', function(){ setCookie('include_next7', cb.checked ? '1' : '0', 365); fetchOccurrencesForCurrentWindow(); });
    }
    const showIg = document.getElementById('show_ignored');
    if (showIg) {
      showIg.checked = (getCookie('show_ignored') === '1');
      showIg.addEventListener('change', function(){ setCookie('show_ignored', showIg.checked ? '1' : '0', 365); fetchOccurrencesForCurrentWindow(); });
    }
  // initial load
  fetchOccurrencesForCurrentWindow();
  // emit a Puppeteer-friendly debug event if helper is available
  try{ if (window.__puppeteerDebug && typeof window.__puppeteerDebug.event === 'function') window.__puppeteerDebug.event('calendar-page-init'); }catch(e){ console.debug('PUPPETEER_DEBUG_RENDER_ISSUE', String(e)); }
  });

  // ignore and complete handlers
  document.addEventListener('click', function(e){
    // single-occurrence ignore button
    const igOcc = e.target.closest('.occ-ignore-occ');
    if (igOcc) {
      const occ = igOcc.getAttribute('data-occ'); if (!occ) return;
      const csrf = getCookie('csrf_token') || '';
      const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=occurrence&scope_key=${encodeURIComponent(occ)}`;
      fetch('/ignore/scope', { method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
        .then(async r => { let j=null; try{ j = await r.json(); }catch(e){ j={error:'invalid-json'};} console.log('DEBUG: ignore_response', {status:r.status, body:j}); const el = igOcc.closest('.todo'); if (el) el.style.display='none'; })
        .catch(err => console.error('DEBUG: ignore_error', err));
      return;
    }
    // ignore from this date button
    const igFrom = e.target.closest('.occ-ignore-from');
    if (igFrom) {
      const todo = igFrom.getAttribute('data-todo'); const occdt = igFrom.getAttribute('data-occ-dt'); if (!todo || !occdt) return;
      const csrf = getCookie('csrf_token') || '';
      // from_dt should be ISO; occdt already provided by server in ISO
      const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=todo_from&scope_key=${encodeURIComponent(todo)}&from_dt=${encodeURIComponent(occdt)}`;
      fetch('/ignore/scope', { method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
        .then(async r => { let j=null; try{ j = await r.json(); }catch(e){ j={error:'invalid-json'};} console.log('DEBUG: ignore_from_response', {status:r.status, body:j}); const el = igFrom.closest('.todo'); if (el) el.style.display='none'; })
        .catch(err => console.error('DEBUG: ignore_from_error', err));
      return;
    }
    // unignore button
    const unIg = e.target.closest('.occ-unignore');
    if (unIg) {
      const occ = unIg.getAttribute('data-occ');
      const itemId = unIg.getAttribute('data-item-id');
      const csrf = getCookie('csrf_token') || '';
      if (occ) {
        const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=occurrence&scope_key=${encodeURIComponent(occ)}`;
        fetch('/ignore/unscope', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_occ_error', err));
      } else if (itemId) {
        const body = `_csrf=${encodeURIComponent(csrf)}&scope_type=todo_from&scope_key=${encodeURIComponent(itemId)}`;
        fetch('/ignore/unscope', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' })
          .then(async r => { try{ await r.json(); }catch(e){} fetchOccurrencesForCurrentWindow(); })
          .catch(err => console.error('DEBUG: unignore_todo_from_error', err));
      }
      return;
    }
    // fall through to other handlers
  });

  document.addEventListener('change', function(e){
    const cb = e.target.closest('.occ-complete'); if (!cb) return; const hash = cb.getAttribute('data-hash'); if (!hash) return;
    // simple in-flight and debounce guard to prevent duplicate toggles
    // caused by rapid duplicate events when fetchOccurrencesForCurrentWindow
    // replaces DOM or on initial page refresh. Keyed by occ_hash.
    window.__occInFlight = window.__occInFlight || {};
    window.__occLastProcessed = window.__occLastProcessed || {};
    const now = Date.now();
    // ignore event if a request for this hash is already in-flight
    if (window.__occInFlight[hash]) {
      console.debug('IGNORING duplicate change - in-flight', hash);
      return;
    }
    // ignore if we processed a change for this hash very recently (debounce 800ms)
    const last = window.__occLastProcessed[hash] || 0;
    if (now - last < 800) {
      console.debug('IGNORING duplicate change - debounced', hash, now - last);
      return;
    }
    if (cb.checked) {
  // mark in-flight and disable checkbox to avoid duplicate clicks and optimistic race
  window.__occInFlight[hash] = true;
  cb.disabled = true;
      const csrf = getCookie('csrf_token') || '';
      const body = `_csrf=${encodeURIComponent(csrf)}&hash=${encodeURIComponent(hash)}`;
      (async () => {
        // Helper to retry once after attempting CSRF refresh
        async function postComplete() {
          const r = await fetch('/occurrence/complete', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' });
          return r;
        }
        let r = await postComplete();
        if (r.status === 403) {
          try {
            // If middleware hinted a refresh or token likely expired, request a refresh and retry once
            await fetch('/csrf/refresh', { method: 'POST', credentials: 'same-origin' });
          } catch (e) { /* ignore */ }
          r = await postComplete();
        }
        let j = null;
        try { j = await r.json(); } catch (e) { j = { error: 'invalid-json' }; }
        console.log('DEBUG: complete_response', { status: r.status, body: j });
        if (!r.ok || (j && typeof j.ok !== 'undefined' && !j.ok)) {
          cb.checked = false;
        }
      })().catch(err => { console.error('DEBUG: complete_error', err); cb.checked = false; })
      .finally(() => { cb.disabled = false; window.__occInFlight[hash] = false; window.__occLastProcessed[hash] = Date.now(); });
    } else {
  // mark in-flight and disable checkbox to avoid duplicate clicks and optimistic race
  window.__occInFlight[hash] = true;
  cb.disabled = true;
      const csrf = getCookie('csrf_token') || '';
      const body = `_csrf=${encodeURIComponent(csrf)}&hash=${encodeURIComponent(hash)}`;
      (async () => {
        async function postUncomplete() {
          const r = await fetch('/occurrence/uncomplete', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: body, credentials: 'same-origin' });
          return r;
        }
        let r = await postUncomplete();
        if (r.status === 403) {
          try { await fetch('/csrf/refresh', { method: 'POST', credentials: 'same-origin' }); } catch (e) {}
          r = await postUncomplete();
        }
        let j = null;
        try { j = await r.json(); } catch (e) { j = { error: 'invalid-json' }; }
        console.log('DEBUG: uncomplete_response', { status: r.status, body: j });
        if (!r.ok || (j && typeof j.ok !== 'undefined' && !j.ok)) {
          cb.checked = true;
        }
      })().catch(err => { console.error('DEBUG: uncomplete_error', err); cb.checked = true; })
      .finally(() => { cb.disabled = false; window.__occInFlight[hash] = false; window.__occLastProcessed[hash] = Date.now(); });
    }
  });
  </script>

  {% endblock %}

{% endblock %}


