<script>
// Shared helper to update visible list names when a list is renamed via AJAX.
// Usage: window.__ft_onListRenamed(listId, newName)
(function(){
  if (typeof window === 'undefined') return;
  // Guarded logger to avoid duplicate rename logs from multiple sources
  function logRenameOnce(listId, displayName){
    try{
      if (!window || !window.ftLog) return;
      var now = Date.now();
      if (!window.__ft_loggedRenames) window.__ft_loggedRenames = {};
      var last = window.__ft_loggedRenames[String(listId)] || 0;
      if ((now - last) < 1500) return; // debounce duplicate logs within 1.5s
      window.__ft_loggedRenames[String(listId)] = now;
      window.ftLog('Renamed list', { item_type: 'list', item_id: Number(listId), label: displayName });
    }catch(_){ }
  }
  function updateAnchors(listId, name){
    try{
      var anchors = Array.from(document.querySelectorAll('a'));
      anchors.forEach(function(a){
        try{
          var href = a.getAttribute('href') || '';
          // match /html_no_js/lists/<id> followed by end, slash, ?, or # to avoid substring collisions (e.g. 17 vs 170)
          var re = new RegExp('(^|\\/)html_no_js\\/lists\\\/' + String(listId) + '(?:$|\\/|\\?|#)');
          // Normalize href by removing protocol/host if present
          var path = href.replace(/^https?:\/\/(?:[^\/]+)\//, '');
          if (re.test(path)){
            a.textContent = name;
          }
        }catch(e){}
      });
    }catch(e){}
  }
  function updateListTitles(listId, name){
    try{
      // update any .list-title anchors or headings
      var els = Array.from(document.querySelectorAll('.list-title')) || [];
    els.forEach(function(a){ try {
        var href = a.getAttribute && a.getAttribute('href') || '';
        if (!href) {
          // only update non-anchor titles when they are clearly tied to the
          // renamed list via a nearby data-list-id wrapper; this prevents a
          // sublist rename from clobbering the page's main list title.
          var wrapper = a.closest && a.closest('[data-list-id]');
          if (wrapper && wrapper.getAttribute && wrapper.getAttribute('data-list-id') === String(listId)) {
            a.textContent = name;
          }
        } else {
          var re = new RegExp('(^|\\/)html_no_js\\/lists\\\/' + String(listId) + '(?:$|\\/|\\?|#)');
          var path = href.replace(/^https?:\/\/(?:[^\/]+)\//, '');
          if (re.test(path)) a.textContent = name;
        }
      } catch(e){} });
      // update H3 or H2 list title without href
    var mainTitle = document.querySelector('h3.list-title') || document.querySelector('.list-title:not([href])');
      if (mainTitle){
        // Ensure it matches the listId by checking nearby data attributes if available
        try{
          var wrapper = mainTitle.closest && mainTitle.closest('[data-list-id]');
          // Only update the main title when its wrapper explicitly matches the renamed list id
          if (wrapper && wrapper.getAttribute && wrapper.getAttribute('data-list-id') === String(listId)) {
            mainTitle.textContent = name;
          } else {
            // Fallback: if there is an edit button for this list id inside the same
            // .list-main container as the mainTitle, consider it the page-level
            // title and update it. This handles the page list render where the
            // h3.title sits alongside an edit button rather than inside a
            // data-list-id wrapper.
            var lm = mainTitle.closest && mainTitle.closest('.list-main');
            if (lm) {
              var editBtnNearby = lm.querySelector && lm.querySelector('.edit-list-btn[data-list-id="' + String(listId) + '"]');
              if (editBtnNearby) mainTitle.textContent = name;
            }
          }
        }catch(e){ mainTitle.textContent = name; }
      }
    }catch(e){}
  }
  function updateEditButtons(listId, name){
    try{
      var editBtn = document.querySelector('.edit-list-btn[data-list-id="' + listId + '"]');
      if (editBtn) editBtn.setAttribute('data-list-name', name);
    }catch(e){}
  }
  function extractTagsFromName(name){
    try{
      var re = /(^|\s)#([A-Za-z][A-Za-z0-9]*)(?=\s|$)/g;
      var out = [];
      var seen = {};
      var m;
      while ((m = re.exec(name)) !== null){
        var body = (m[2] || '').toLowerCase();
        if (!body) continue;
        if (!/^[a-z][a-z0-9]*$/.test(body)) continue;
        if (!seen[body]){ seen[body] = true; out.push('#' + body); }
      }
      return out;
    }catch(e){ return []; }
  }

  function renderTagsInto(container, tags){
    try{
      // Do not remove existing tag chips here â€” renames must not remove previously
      // visible tags. Instead merge: collect existing tag-chip texts and only
      // append tags that are not already present.
      var existing = Array.from(container.querySelectorAll && container.querySelectorAll('.tag-chip') || []).map(function(el){ return (el.textContent || '').trim(); });
      var seen = {};
      existing.forEach(function(t){ if (t) seen[t] = true; });
      // If no tags provided, leave existing DOM unchanged (don't clear it).
      if (!tags || !tags.length){
        // set aria-hidden appropriately
        if (existing.length === 0) container.setAttribute('aria-hidden','true'); else container.setAttribute('aria-hidden','false');
        return;
      }
      tags.forEach(function(tag){
        if (!tag) return;
        if (seen[tag]) return; // already present
        seen[tag] = true;
        // Match server-rendered structure: <div role="listitem" style="display:inline-block;margin-right:0.35rem"><a class="tag-chip">#tag</a></div>
        var wrap = document.createElement('div');
        try { wrap.setAttribute('role', 'listitem'); } catch(e){}
        try { wrap.style.display = 'inline-block'; wrap.style.marginRight = '0.35rem'; } catch(e){}
        var a = document.createElement('a'); a.className = 'tag-chip'; a.href = '/html_no_js/search?q=' + encodeURIComponent(tag); a.textContent = tag;
        wrap.appendChild(a);
        container.appendChild(wrap);
      });
      // If there were neither existing nor appended tags, mark hidden
      var any = Object.keys(seen).length > 0;
      container.setAttribute('aria-hidden', any ? 'false' : 'true');
    }catch(e){}
  }

  function updateListTags(listId, name, providedTags){
    try{
  var tags = Array.isArray(providedTags) ? providedTags : extractTagsFromName(name);
  var explicitEmpty = Array.isArray(providedTags) && providedTags.length === 0;
      // 1) Update inline index/category containers which use .all-tags-inline[data-list-id]
  var allInline = document.querySelectorAll('.all-tags-inline[data-list-id="' + listId + '"]');
  allInline.forEach(function(c){ try{ if (explicitEmpty) { /* clear */ while(c.firstChild) c.removeChild(c.firstChild); c.setAttribute('aria-hidden','true'); } else { renderTagsInto(c, tags); } }catch(e){} });

      // 2) Update any explicit `.tags` or `.tags-inline` block inside .list-main or .list-item.
      // First, try to locate wrappers by an explicit data-list-id attribute (used on some list renderings).
      var selector = '[data-list-id="' + listId + '"]';
      var wrappers = document.querySelectorAll(selector);
      wrappers.forEach(function(w){
        try{
          var tagsBlock = w.querySelector('.tags') || w.querySelector('.tags-inline') || w.querySelector('.all-tags-inline');
          if (tagsBlock) {
            if (explicitEmpty) { while(tagsBlock.firstChild) tagsBlock.removeChild(tagsBlock.firstChild); tagsBlock.setAttribute('aria-hidden','true'); }
            else { renderTagsInto(tagsBlock, tags); }
          }
        }catch(e){}
      });
      // If no wrappers found by data-list-id (common for sublists), find anchors that link to the list
      // and update their nearby .list-main/.list-item tag blocks.
      try{
        var anchors = document.querySelectorAll('a.list-title');
        var re = new RegExp('(^|\\/)html_no_js\\/lists\\\/' + String(listId) + '(?:$|\\/|\\?|#)');
        anchors.forEach(function(a){
          try{
            var href = a.getAttribute('href') || '';
            var path = href.replace(/^https?:\/\/(?:[^\/]+)\//, '');
            if (!re.test(path)) return;
            var container = a.closest && (a.closest('.list-main') || a.closest('.list-item'));
            if (!container) container = a.parentElement;
            if (!container) return;
            var tagsBlock = container.querySelector('.tags') || container.querySelector('.tags-inline') || container.querySelector('.all-tags-inline');
            // If there is no tags container but we have explicit (non-empty) tags, create one
            if (!tagsBlock && !explicitEmpty && Array.isArray(tags) && tags.length > 0) {
              try {
                tagsBlock = document.createElement('div');
                tagsBlock.className = 'tags';
                tagsBlock.setAttribute('role', 'list');
                tagsBlock.setAttribute('aria-label', 'List tags');
                // Insert after the anchor within the container if possible, otherwise append
                if (a.nextSibling) container.insertBefore(tagsBlock, a.nextSibling); else container.appendChild(tagsBlock);
              } catch(e) { tagsBlock = null; }
            }
            if (!tagsBlock) return;
            if (explicitEmpty) { while(tagsBlock.firstChild) tagsBlock.removeChild(tagsBlock.firstChild); tagsBlock.setAttribute('aria-hidden','true'); }
            else { renderTagsInto(tagsBlock, tags); }
          }catch(e){}
        });
      }catch(e){}

      // 3) Update the list page header tags (if present) by finding .list-main that contains the edit button for this id
      var editBtn = document.querySelector('.edit-list-btn[data-list-id="' + listId + '"]');
      if (editBtn){
        try{
          var lm = editBtn.closest && editBtn.closest('.list-main');
          if (lm){
            var headerTags = lm.querySelector('.tags') || lm.querySelector('.tags-inline') || lm.querySelector('.all-tags-inline');
            // If the header tags container is missing but we have explicit tags, create it so the page list shows chips immediately
            if (!headerTags && !explicitEmpty && Array.isArray(tags) && tags.length > 0) {
              try {
                headerTags = document.createElement('div');
                headerTags.className = 'tags';
                headerTags.setAttribute('role', 'list');
                headerTags.setAttribute('aria-label', 'List tags');
                lm.appendChild(headerTags);
              } catch(e) { headerTags = null; }
            }
            if (headerTags) { if (explicitEmpty) { while(headerTags.firstChild) headerTags.removeChild(headerTags.firstChild); headerTags.setAttribute('aria-hidden','true'); } else { renderTagsInto(headerTags, tags); } }
          }
        }catch(e){}
      }
    }catch(e){ /* ignore */ }
  }

  // Fetch authoritative tags from server for a list and render into containers.
  function fetchAndRenderListTags(listId){
    try{
      fetch('/lists/' + encodeURIComponent(listId) + '/hashtags?include_todo_tags=0&combine=0', { credentials: 'same-origin' })
        .then(function(res){ if (!res.ok) throw new Error('fetch tags failed'); return res.json(); })
        .then(function(data){
          try{
            var tags = (data && data.hashtags) ? data.hashtags : [];
            // If server authoritatively returned an empty array, clear existing DOM tag chips
            var containers = document.querySelectorAll('.all-tags-inline[data-list-id="' + listId + '"]');
            if (Array.isArray(tags) && tags.length === 0) {
              containers.forEach(function(c){ try{ while(c.firstChild) c.removeChild(c.firstChild); c.setAttribute('aria-hidden','true'); }catch(e){} });
              var wrappers = document.querySelectorAll('[data-list-id="' + listId + '"]');
              wrappers.forEach(function(w){ try{ var tb = w.querySelector('.tags') || w.querySelector('.tags-inline') || w.querySelector('.all-tags-inline'); if (tb) { while(tb.firstChild) tb.removeChild(tb.firstChild); tb.setAttribute('aria-hidden','true'); } }catch(e){} });
            } else {
              // render into any inline containers
              containers.forEach(function(c){ try{ renderTagsInto(c, tags); }catch(e){} });
              // also update nearby .tags or .tags-inline blocks
              var wrappers = document.querySelectorAll('[data-list-id="' + listId + '"]');
              wrappers.forEach(function(w){ try{ var tb = w.querySelector('.tags') || w.querySelector('.tags-inline') || w.querySelector('.all-tags-inline'); if (tb) renderTagsInto(tb, tags); }catch(e){} });
            }
          }catch(e){}
        })
        .catch(function(){ /* ignore fetch errors */ });
    }catch(e){}
  }
  window.__ft_onListRenamed = function(listId, name, tags){
    try{
      // If server provided tags, prefer them; otherwise derive from name
      var effectiveTags = Array.isArray(tags) ? tags : extractTagsFromName(name || '');
        var explicitEmpty = Array.isArray(tags) && tags.length === 0;
      // strip inline hashtags from displayed title
      var displayName = (name || '').replace(/(^|\s)#([A-Za-z][A-Za-z0-9]*)(?=\s|$)/g, '').replace(/\s+/g,' ').trim();
      updateAnchors(listId, displayName);
      updateListTitles(listId, displayName);
      updateEditButtons(listId, displayName);
      // Update visible tag chips based on explicit/effective tags; prefer server-provided `effectiveTags` when present
      try { updateListTags(listId, displayName, effectiveTags); } catch(e){}
      try {
        // if server returned no explicit tags and updateListTags couldn't render any (containers absent), fetch authoritative tags
        var anyInline = document.querySelectorAll('.all-tags-inline[data-list-id="' + listId + '"]');
        var anyTagsRendered = (anyInline && anyInline.length > 0);
        if ((!effectiveTags || !effectiveTags.length) && !anyTagsRendered) {
          try{ fetchAndRenderListTags(listId); } catch(e){}
        }
          // If the server explicitly provided an empty array of tags treat that
          // as authoritative and remove any remaining visible tag chips for this
          // list. This covers DOM shapes where the previous merge-based logic
          // failed to locate the tag container.
          if (explicitEmpty) {
            try {
              // clear any indexed inline containers
              var inlineContainers = document.querySelectorAll('.all-tags-inline[data-list-id="' + listId + '"]');
              inlineContainers.forEach(function(c){ try{ while(c.firstChild) c.removeChild(c.firstChild); c.setAttribute('aria-hidden','true'); }catch(e){} });
              // clear any .tags blocks inside elements that reference the list id
              var wrappers = document.querySelectorAll('[data-list-id="' + listId + '"]');
              wrappers.forEach(function(w){ try{ var tb = w.querySelector('.tags') || w.querySelector('.tags-inline') || w.querySelector('.all-tags-inline'); if (tb) { while(tb.firstChild) tb.removeChild(tb.firstChild); tb.setAttribute('aria-hidden','true'); } }catch(e){} });
              // also find anchors that point to the list and clear nearby tag blocks
              var anchors = document.querySelectorAll('a.list-title');
              var re = new RegExp('(^|\\/)html_no_js\\/lists\\\/' + String(listId) + '(?:$|\\/|\\?|#)');
              anchors.forEach(function(a){ try{ var href = a.getAttribute('href') || ''; var path = href.replace(/^https?:\/\/(?:[^\/]+)\//, ''); if (!re.test(path)) return; var container = a.closest && (a.closest('.list-main') || a.closest('.list-item')); if (!container) container = a.parentElement; if (!container) return; var tagsBlock = container.querySelector('.tags') || container.querySelector('.tags-inline') || container.querySelector('.all-tags-inline'); if (!tagsBlock) return; while(tagsBlock.firstChild) tagsBlock.removeChild(tagsBlock.firstChild); tagsBlock.setAttribute('aria-hidden','true'); }catch(e){} });
            } catch(e){}
          }
      } catch(e){}
      // Ensure a single rename log is emitted per action (debounced)
      try{ logRenameOnce(listId, displayName); }catch(_){ }
    }catch(e){ /* ignore */ }
  };
})();
</script>
