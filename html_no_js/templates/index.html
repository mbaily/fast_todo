{% extends 'base.html' %}
{% block title %}Lists ‚Äî Fast Todo (no-js){% endblock %}
{% block content %}
  <!-- Section: Page styles specific to index view (layout and mobile tweaks) -->
  <style>
    /* index-only: remove top page margin so the site title sits flush to the top */
    body { margin-top: 0 !important; }
    header { margin-top: 0 !important; }
  /* show completed lists as struck-through on the index */
  .lists-list .list-title.done { text-decoration: line-through; color: #6b7280; }
  /* pinned list: remove default bullets and left padding */
  .pinned-todos ul { list-style: none; padding-left: 0; margin-left: 0; }
  /* high-priority: present as compact unbulleted list like pinned section */
  .high-priority ul { list-style: none; padding-left: 0; margin-left: 0; }
  /* category lists: align flush under headers (no indent/bullets) */
  .category-lists { list-style: none; padding-left: 0; margin-left: 0; }
  /* ensure completed todos in the pinned section appear struck-through */
  .pinned-todos .done { text-decoration: line-through; color: #6b7280; }
    /* mobile tweak: show list meta on its own line under the title for small screens */
    @media (max-width: 480px) {
  .list-item { position: relative; padding-right: 0.5rem; }
      /* make the title, edit button and meta flow inline and wrap naturally
        Reserve right padding so content doesn't flow under the absolutely
        positioned delete control; use border-box so padding reduces content
        width rather than increasing overall element size. */
      .list-main { display: block; padding-right: calc(var(--page-side-margin) + 1rem); box-sizing: border-box; }
  .list-title { display: inline; vertical-align: middle; }
  .list-main .list-title { white-space: normal; overflow: visible; text-overflow: clip; overflow-wrap: anywhere; word-break: break-word; min-width: 0; }
    /* Mobile override: allow list titles to wrap and shrink. Use higher
       specificity and !important to override desktop ellipsize rules. */
    .lists-list .list-main .list-title {
      white-space: normal !important;
      overflow: visible !important;
      text-overflow: clip !important;
      overflow-wrap: anywhere !important;
      word-break: break-word !important;
      min-width: 0 !important;
    }
  .edit-list-btn { display: inline; margin-left: 0.4rem; vertical-align: middle; }
  /* move the trash/delete control into the line on the right */
  /* push the icon further into the page margin so it sits nearer the physical
    right edge of the viewport. Increase negative offset to move it outward. */
  /* place the left action visually into the page gutter (same as before). If this creates layout overflow
    on some devices we can instead place it with transform, but that previously shifted icons.
    Reverting to the original so icons appear where expected. */
  /* avoid using a negative `right` value which can expand layout width and
    cause horizontal overflow on some mobile browsers (triggering inset
    overlay scrollbars). Use transform to move the control visually into the
    page gutter; transforms don't affect layout width. This is scoped to
    the small-screen mobile override above. */
  .list-action-left { position: absolute; right: 0; top: 0.5rem; width: auto; flex: initial; display: inline-block; transform: translateX(calc(var(--page-side-margin) + 2.5rem)); will-change: transform; }
  .list-main .meta { display: inline; margin-left: 0.45rem; margin-top: 0; vertical-align: middle; overflow-wrap: anywhere; word-break: break-word; }
    }
  </style>
  <style>
    /* count for uncompleted todos */
    .count-circle { font-size: 1rem; line-height: 1; }
  /* override/secondary priority marker: use a distinct accent; same absolute size as primary */
    .count-circle.colour { color: #ff002b; font-size: 1rem; }
  </style>
  <!-- Temporarily disable hashtag suggestion box on index page -->
  <style>
    /* makes sure any suggestion UI is hidden on index while we stabilize mobile scrolling */
    .hashtag-suggest { display: none !important; }
  </style>
  <style>
    /* Mobile: ensure `main` does not create an inner scroll container so iOS shows only one overlay scrollbar.
       This is targeted and preserves desktop/Chrome behavior. */
    @media (pointer: coarse) {
  main { overflow: visible !important; -webkit-overflow-scrolling: touch; min-height: 100vh !important; height: auto !important; }
  /* also make sure direct list container doesn't clip: allow it to grow */
  .lists-list { overflow: visible !important; }
    }
  </style>
  <style>
    /* Make html match the app background so Safari doesn't show the theme-color blue in page margins */
    html { background: var(--bg); }
  </style>
  

  <!-- Section: High priority (todos and lists) -->
  {% if high_priority_todos and high_priority_todos|length > 0 or high_priority_lists and high_priority_lists|length > 0 %}
    <section class="high-priority">
      <h3>High priority</h3>
      <ul>
      {% for item in high_priority_items %}
        <li>
          {% set circ = {0:'‚ì™',1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
          {% if item.kind == 'todo' %}
            <a class="wrap-text{% if item.completed %} done{% endif %}" href="/html_no_js/todos/{{ item.id }}">{{ item.text }}</a>
            {% if item.effective_priority is not none %}
              <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(item.effective_priority, item.effective_priority) }}</span></span>
            {% endif %}
            <span class="meta">in <a href="/html_no_js/lists/{{ item.list_id }}">{{ item.list_name or item.list_id }}</a></span>
          {% else %}
            <a class="list-title" href="/html_no_js/lists/{{ item.id }}">{{ item.name }}</a>
            {% if item.effective_priority is not none %}
              <span class="meta priority-inline priority-override" title="Highest uncompleted todo priority"><span class="priority-circle">{{ circ.get(item.effective_priority, item.effective_priority) }}</span></span>
            {% endif %}
            {% if item.uncompleted_count is not none %}<span class="count-circle colour">{{ item.uncompleted_count }}</span>{% endif %}
          {% endif %}
        </li>
      {% endfor %}
      </ul>
    </section>
  {% endif %}

  <!-- Section: Pinned (todos and lists together) -->
  {% if (pinned_todos and pinned_todos|length > 0) or (pinned_lists and pinned_lists|length > 0) %}
        <section class="pinned-todos">
          <ul>
            {% if pinned_todos and pinned_todos|length > 0 %}
              {% for t in (pinned_todos | sort(attribute='modified_at') | reverse) %}
                <li>
                  <span class="pin-icon {% if t.pinned|default(false) %}pinned{% endif %}">{{ 'üìå' if t.pinned|default(false) else 'üìç' }}</span>
                  <a class="wrap-text{% if t.completed %} done{% endif %}" href="/html_no_js/todos/{{ t.id }}">{{ t.text }}</a>{% if t.priority %} {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %} <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(t.priority, t.priority) }}</span></span>{% endif %}
                  <span class="meta">in <a href="/html_no_js/lists/{{ t.list_id }}">{{ t.list_name or t.list_id }}</a></span>
                  {% if t.note %}
                    <div class="meta line-clamp-1 wrap-text" style="margin-top:0.15rem; max-width:60ch;">{{ t.note }}</div>
                  {% endif %}
                  {% if t.last_journal_entry %}
                    <div class="meta line-clamp-1 wrap-text" style="margin-top:0.15rem; max-width:60ch;">üìù {{ t.last_journal_entry }}</div>
                  {% endif %}
                  {% if t.tags and t.tags|length > 0 %}
                    <div class="tags-inline">
                      {% for tag in (t.tags | sort) %}
                        <a class="tag-chip" href="/html_no_js/search?q={{ tag|urlencode }}">{{ tag }}</a>
                      {% endfor %}
                    </div>
                  {% endif %}
                </li>
              {% endfor %}
            {% endif %}

            {% if pinned_lists and pinned_lists|length > 0 %}
              {% for lst in (pinned_lists | sort(attribute='name', case_sensitive=false)) %}
                <li>
                  <span class="list-icon" title="List">üìÅ</span>
                  <a class="list-title" href="/html_no_js/lists/{{ lst.id }}">{{ lst.name }}</a>
                  {% set lp = lst.priority %}
                  {% set op = lst.override_priority %}
                  {% if lp %}
                    {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
                    <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(lp, lp) }}</span></span>
                  {% endif %}
                  {% if op is not none and (lp is none or op > lp) %}
                    {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
                    <span class="meta priority-inline priority-override" title="Highest uncompleted todo priority"><span class="priority-circle">{{ circ.get(op, op) }}</span></span>
                  {% endif %}
                  {% if lst.uncompleted_count is not none %}<span class="count-circle colour">{{ lst.uncompleted_count }}</span>{% endif %}
                </li>
              {% endfor %}
            {% endif %}
          </ul>
        </section>
      {% endif %}

  {# Calendar summary: now directly under pinned, before bookmarks #}
  {% if calendar_occurrences and calendar_occurrences|length > 0 %}
    <section class="calendar-summary">
      <!--<h3>Calendar</h3>-->
      <ul style="list-style:none;padding-left:0;margin:0 0 1rem 0;">
        {% for ev in calendar_occurrences %}
          <li>
            <strong>{{ ev.occurrence_date or ev.occurrence_dt[:10] }}</strong>
            &nbsp; <a href="{% if ev.item_type == 'todo' %}/html_no_js/todos/{{ ev.id }}{% else %}/html_no_js/lists/{{ ev.id }}{% endif %}">{{ ev.title or (ev.rrule or '')[:60] }}</a>
            {% if ev.item_type == 'todo' and ev.priority %}
              {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
              <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(ev.priority, ev.priority) }}</span></span>
            {% endif %}
            {% if ev.is_recurring %}<span class="muted"> (recurring)</span>{% endif %}
          </li>
        {% endfor %}
      </ul>
    </section>
  {% endif %}
  {% if config.DEV_MODE %}
    <div class="dev-banner" style="position:sticky;top:0;z-index:900;background:#7c2d12;color:#fff;padding:0.35rem 0.6rem;border-bottom:2px solid #f97316;letter-spacing:0.03em;text-align:center;font-weight:700;margin:0.25rem 0;">
      DEVELOPMENT SERVER
    </div>
  {% endif %}

  <!-- Section: Bookmarks (todos and lists) -->
  {% if (bookmarked_todos and bookmarked_todos|length > 0) or (bookmarked_lists and bookmarked_lists|length > 0) %}
    <section class="pinned-todos">
      <!-- <h3>Bookmarks</h3> -->
      {% if bookmarked_todos and bookmarked_todos|length > 0 %}
      <ul>
        {% for t in (bookmarked_todos | sort(attribute='text', case_sensitive=false)) %}
          <li>
            <span class="pin-icon">üîñ</span>
            <a class="wrap-text{% if t.completed %} done{% endif %}" href="/html_no_js/todos/{{ t.id }}">{{ t.text }}</a>{% if t.priority %} {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %} <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(t.priority, t.priority) }}</span></span>{% endif %}
            {% if t.override_priority is not none and (t.priority is none or t.override_priority > t.priority) %}{% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %} <span class="meta priority-inline priority-override" title="Secondary priority (max child sublists)"><span class="priority-circle">{{ circ.get(t.override_priority, t.override_priority) }}</span></span>{% endif %}
            <span class="meta">in <a href="/html_no_js/lists/{{ t.list_id }}">{{ t.list_name or t.list_id }}</a></span>
            {% if t.tags and t.tags|length > 0 %}
            <div class="tags-inline">
              {% for tag in (t.tags | sort) %}
                <a class="tag-chip" href="/html_no_js/search?q={{ tag|urlencode }}">{{ tag }}</a>
              {% endfor %}
            </div>
            {% endif %}
          </li>
        {% endfor %}
      </ul>
      {% endif %}
      {% if bookmarked_lists and bookmarked_lists|length > 0 %}
      <ul>
        {% for lst in (bookmarked_lists | sort(attribute='name', case_sensitive=false)) %}
          <li>
            <span class="pin-icon">üîñ</span>
            <a class="list-title" href="/html_no_js/lists/{{ lst.id }}">{{ lst.name }}</a>
            {# Show primary list priority if present #}
            {% set lp = lst.priority %}
            {% set op = lst.override_priority %}
            {% if lp %}
              {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
              <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(lp, lp) }}</span></span>
            {% endif %}
            {# If override exists and is strictly greater than primary, show it as an override badge (sand-colour) #}
            {% if op is not none and (lp is none or op > lp) %}
              {% set circ = {1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
              <span class="meta priority-inline priority-override" title="Highest uncompleted todo priority"><span class="priority-circle">{{ circ.get(op, op) }}</span></span>
            {% endif %}
            {% if lst.uncompleted_count is not none %}<span class="count-circle colour">{{ lst.uncompleted_count }}</span>{% endif %}
          </li>
        {% endfor %}
      </ul>
      {% endif %}
    </section>
  {% endif %}
  <!-- Section: Search form (lists and todos) -->
  <form id="index-search-form" method="get" action="/html_no_js/search" style="margin:0.5rem 0; display:flex; gap:0.4rem; align-items:center;">
    <input id="index-search-q" name="q" placeholder="Search lists and todos" value="{{ request.query_params.get('q','') }}" style="flex:1 1 auto; min-width:0;">
    <input id="index-search-mode" type="hidden" name="mode" value="normal">
    <button id="index-search-mode-btn" type="button" aria-label="Toggle search mode" title="Toggle search mode" style="min-width:2.5rem;">‚óè</button>
    <button type="submit">Search</button>
  </form>
  <script>
  (function(){
    var form = document.getElementById('index-search-form'); if (!form) return;
    var btn = document.getElementById('index-search-mode-btn');
    var hid = document.getElementById('index-search-mode');
    var q = document.getElementById('index-search-q');
    var MODES = [
      { key: 'normal', label: '‚óè', color: '#444', title: 'Normal search' },
      { key: 'lists',  label: 'L', color: '#10b981', title: 'Lists only' },
      { key: 'todos',  label: 'T', color: '#7c3aed', title: 'Todos only' }
    ];
    function setMode(idx){
      try{
        var m = MODES[idx];
        hid.value = m.key;
        btn.textContent = m.label;
        btn.style.background = m.color;
        btn.style.color = '#fff';
        btn.title = m.title;
        btn.setAttribute('aria-label', m.title);
        localStorage.setItem('ft_search_mode', m.key);
      }catch(e){}
    }
    function getIndexByKey(k){ for (var i=0;i<MODES.length;i++){ if (MODES[i].key===k) return i; } return 0; }
    var saved = null; try{ saved = localStorage.getItem('ft_search_mode'); }catch(e){}
    var idx = getIndexByKey(saved||'normal');
    setMode(idx);
    btn.addEventListener('click', function(){ idx = (idx+1) % MODES.length; setMode(idx); });
    form.addEventListener('submit', function(){ try{ if (!q.value) q.focus(); }catch(e){} });
  })();
  </script>
  <!-- Section: Quick add todo (creates todo into 'Quick' list) -->
  <form id="quick-add-form" autocomplete="off" style="margin:0.4rem 0; display:flex; gap:0.5rem; align-items:center;">
    {{ csrf_field() }}
    <input id="quick-add-text" placeholder="Quick todo" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" style="flex:1 1 auto; min-width:0;">
    <button id="quick-add-btn" type="button">Add</button>
  </form>
  <script>
  (function(){
    var form = document.getElementById('quick-add-form'); if (!form) return;
    var input = document.getElementById('quick-add-text'); var btn = document.getElementById('quick-add-btn');
    // On page load, check for pending quick-add saved across reloads
    try{
      var pending = sessionStorage.getItem('ft_quick_pending');
      if (pending){
        (async function(pt){
          try{
            // try to find Quick list and post todo
            var tryId = await findQuickListId();
            if (tryId){
              await fetch('/todos', { method: 'POST', credentials: 'same-origin', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify({ text: pt, list_id: tryId, priority: 7 }) });
            }
          }catch(e){}
          try { sessionStorage.removeItem('ft_quick_pending'); } catch(e){}
        })(pending);
      }
    }catch(e){}
    async function findQuickListId(){
      try{
        // Look for rendered top-level list anchor with exact text 'Quick'
        var anchors = Array.from(document.querySelectorAll('a[href^="/html_no_js/lists/"]'));
        for (var i=0;i<anchors.length;i++){ var a = anchors[i]; if ((a.textContent||'').trim() === 'Quick'){
            var m = (a.getAttribute('href')||'').match(/\/(?:html_no_js\/)?lists\/(\d+)/);
            if (m) return Number(m[1]);
        }}
      }catch(e){}
      return null;
    }
  btn.addEventListener('click', async function(){
      var text = input.value && input.value.trim(); if (!text) return;
      
      btn.disabled = true;
      try{
        var listId = await findQuickListId();
        
        if (!listId){
          // create 'Quick' list via JSON API (preferred)
          try{
            var res = await fetch('/lists', { method: 'POST', credentials: 'same-origin', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify({ name: 'Quick' }) });
            if (res){
              try{ var j = await res.json(); listId = j && j.id; } catch(e){}
            }
          }catch(e){}
        }
        // Fallback: if JSON API didn't return an id, submit the HTML form endpoint and re-scan for the Quick anchor
        if (!listId){
          try{
            // Save pending todo text across the reload so we can finish creation after the server renders the new list
            try { sessionStorage.setItem('ft_quick_pending', text); } catch(e){}
            var formBody = new URLSearchParams(); formBody.append('name','Quick');
            var csrf = document.querySelector('input[name="_csrf"]'); if (csrf && csrf.value) formBody.append('_csrf', csrf.value);
            await fetch('/html_no_js/lists/create', { method: 'POST', credentials: 'same-origin', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: formBody.toString() });
            // Reload so the new list appears in DOM; pending todo will be created on load
            try { window.location.reload(); return; } catch(e) { /* ignore */ }
          }catch(e){}
        }
  if (!listId) throw new Error('could not determine Quick list id');
  // create todo with priority 7 via JSON API
  
  var tres = await fetch('/todos', { method: 'POST', credentials: 'same-origin', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify({ text: text, list_id: listId, priority: 7 }) });
  try{
    var todo_txt = await tres.text();
    // attempt to parse as JSON
    try{ var todo = JSON.parse(todo_txt); } catch(e){ var todo = null; }
    if (!tres.ok) throw new Error('create todo failed status=' + tres.status);
  }catch(e){ throw e; }
  // Clear input and focus
  input.value = '';
  input.focus();
  
  // Log quick add
  try{ if (window.ftLog){ window.ftLog('Added quick todo', { item_type: 'todo', item_id: (todo && todo.id) ? Number(todo.id) : null, label: String(text||'') }); } }catch(_){ }
  
  // Refresh index so the created todo appears in the Quick list without navigating away
  try { window.location.reload(); } catch(e){}
      }catch(err){ console && console.error && console.error('Quick add failed', err); try{ alert('Add failed'); }catch(_){}}
      finally{ btn.disabled = false; }
    }, false);
    // Ensure pressing Enter in the input triggers the same quick-add flow
    form.addEventListener('submit', function(ev){
      try{ ev.preventDefault(); }catch(e){}
      try{ btn.click(); }catch(e){}
    }, false);
  })();
  </script>
  <!-- Section: Create list form -->
  <form method="post" action="/html_no_js/lists/create">
  {% if user_default_category_id is defined and user_default_category_id is not none %}
  <input type="hidden" name="category_id" value="{{ user_default_category_id }}">
  {% else %}
  <input type="hidden" name="category_id" value="">
  {% endif %}
  {{ csrf_field() }}
  <input name="name" placeholder="List name" required>
    <button type="submit">Create</button>
  </form>

  {% if recent_lists_24h and recent_lists_24h|length > 0 %}
  <div class="meta" style="margin:0.35rem 0 0.6rem;">
    <strong>üïí Created in last 24h:</strong>
    <ul style="list-style:none; padding-left:0; margin:0.25rem 0 0; display:flex; gap:0.75rem; flex-wrap:wrap;">
      {% for r in recent_lists_24h %}
        <li style="display:inline-flex; align-items:center; gap:0.25rem;">
          <span aria-hidden="true" title="Created in last 24h">üïí</span>
          <a href="/html_no_js/lists/{{ r.id }}" title="Created {{ r.created_at|in_tz(client_tz, '%d/%m %-I:%M%p') }}">{{ r.name }}</a>
        </li>
      {% endfor %}
    </ul>
  </div>
  {% endif %}

    <script>
    // Ensure hashtags typed inline in the list name are sent explicitly as a
    // `hashtags` value (comma-separated) so server-side create_list can persist them.
    (function(){
      try {
        var form = document.querySelector('form[action="/html_no_js/lists/create"]');
        if (!form) return;
        form.addEventListener('submit', function(ev){
       /* NOTE: When creating or renaming lists, client-side code must not
         remove existing tag chips from the DOM. Tag removals are handled
         by dedicated endpoints and UI controls elsewhere. This submit
         handler only extracts inline hashtags and appends them as an
         explicit `hashtags` form value so the server can persist them. */
          try {
            var nameInput = form.querySelector('input[name="name"]');
            var v = nameInput && nameInput.value ? nameInput.value : '';
            // Log list creation attempt (use sendBeacon to survive navigation)
            try {
              if (v) {
                var payload = { message: 'Added list', item_type: 'list', item_id: null, url: (window.location ? window.location.href : null), label: String(v).trim() };
                if (navigator && navigator.sendBeacon) {
                  try { var blob = new Blob([JSON.stringify(payload)], { type: 'application/json' }); navigator.sendBeacon('/html_no_js/logs', blob); }
                  catch(e){ if (window.ftLog) window.ftLog('Added list', { item_type: 'list', item_id: null, label: String(v).trim() }); }
                } else if (window.ftLog) {
                  window.ftLog('Added list', { item_type: 'list', item_id: null, label: String(v).trim() });
                }
              }
            } catch(_){ }
            if (!nameInput) return;
            // find hashtag tokens like #tag (letter then alnum)
                // Extract hashtags without using lookbehind to maximize browser support.
                var re = /(^|\s)#([A-Za-z][A-Za-z0-9]*)(?=\s|$)/g;
                var seen = {};
                var out = [];
                var mm;
                while ((mm = re.exec(v)) !== null) {
                  var body = mm[2] || '';
                  var t = body.toLowerCase();
                  if (!t) continue;
                  if (!/^[a-z][a-z0-9]*$/.test(t)) continue;
                  if (!seen[t]) { seen[t] = true; out.push('#' + t); }
                }
        // if no hashtags were found, skip adding the hidden field but continue submission
            // attach hidden input named `hashtags` with comma-separated tags
            var existing = form.querySelector('input[name="hashtags"]');
            if (existing) existing.value = out.join(',');
            else {
              var hi = document.createElement('input'); hi.type = 'hidden'; hi.name = 'hashtags'; hi.value = out.join(','); form.appendChild(hi);
            }
            // hashtag field attachment done (logging already emitted above)
          } catch(e) { console && console.debug && console.debug('create-list hashtags extract failed', e); }
        }, false);
      } catch(e){}
    })();
    </script>
  
  {% if cursors %}
    <nav class="pagination" aria-label="Pages">
      {% if cursors.has_prev %}
        <a href="?dir=prev&cursor_created_at={{ cursors.prev_cursor_created_at|urlencode }}&cursor_id={{ cursors.prev_cursor_id }}">&laquo; Newer</a>
      {% endif %}
      {% if cursors.has_next %}
        <a href="?dir=next&cursor_created_at={{ cursors.next_cursor_created_at|urlencode }}&cursor_id={{ cursors.next_cursor_id }}">Older &raquo;</a>
      {% endif %}
    </nav>
  {% endif %}
  <!-- Section: Uncategorized and categorized lists -->
  <ul class="lists-list">
  {# Uncategorized (no category) - render first so it appears at the top #}
  {% set uncats = lists_by_category.get(0, []) %}
  {% if uncats and uncats|length > 0 %}
    <li class="category-section" data-category-id="uncategorized">
      <h3 class="category-header" data-target="cat-uncat" style="cursor:pointer; user-select:none;">
        <span class="twisty" aria-hidden="true">‚ñæ</span>
        <span class="category-name">Uncategorized</span>
        <span class="count muted"> ({{ uncats|length }})</span>
      </h3>
      <ul id="cat-uncat" class="category-lists">
        {% for lst in uncats %}
          {% set created_iso = lst.created_at|in_tz(client_tz, '%Y-%m-%dT%H:%M:%S') %}
          {% set modified_iso = lst.modified_at|in_tz(client_tz, '%Y-%m-%dT%H:%M:%S') if lst.modified_at else None %}
          {# effective priority: use override_priority when present and higher than list.priority #}
          {% set eff = lst.override_priority if (lst.override_priority is not none and (lst.priority is none or lst.override_priority > lst.priority)) else lst.priority %}
          {% set circ = {0:'‚ì™',1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
          <li class="list-item"{% if created_iso %} data-created-at="{{ created_iso }}"{% endif %}{% if modified_iso %} data-modified-at="{{ modified_iso }}"{% endif %} data-priority="{{ eff if eff is not none else '' }}">
            <div class="list-main">
              <a class="list-title {% if lst.completed %}done{% endif %}" href="/html_no_js/lists/{{ lst.id }}">{{ lst.name }}</a>
 
              <!--<button type="button" class="list-action-btn edit-list-btn" data-list-id="{{ lst.id }}" data-list-name="{{ lst.name|e }}" title="Edit list name">‚úèÔ∏è</button>-->
                {% if lst.priority %}
                <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(lst.priority, lst.priority) }}</span></span>
                {% endif %}
                {% if lst.override_priority and (lst.priority is none or lst.override_priority > lst.priority) %}
                  <span class="meta priority-inline priority-override" title="Highest uncompleted todo priority"><span class="priority-circle">{{ circ.get(lst.override_priority, lst.override_priority) }}</span></span>
              {% endif %}
              {% if lst.uncompleted_count is not none and not (lst.hide_icons|default(false)) %}
                <span class="count-circle colour" aria-hidden="false" title="{{ lst.uncompleted_count }} uncompleted todos">{{ lst.uncompleted_count }}</span>
              {% endif %}
              {% if lst.created_at %}
                <div class="meta">cr. {{ lst.created_at|in_tz(client_tz, '%d/%m %-I:%M%p') }}</div>
              {% endif %}
                {# SSR: prefer server-provided combined hashtags (computed in handler) when available #}
                {% if lst.combined is defined and lst.combined is not none %}
                  {% set combined = lst.combined %}
                {% else %}
                  {% set combined = [] %}
                  {% if lst.hashtags %}
                    {% for t in lst.hashtags %}
                      {% if t not in combined %}
                        {% set combined = combined + [t] %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}
                  {% if lists is defined %}
                    {% for lrow in lists %}
                      {% if lrow.id == lst.id %}
                        {% if lrow.hashtags is defined and lrow.hashtags %}
                          {% for t in lrow.hashtags %}
                            {% if t not in combined %}
                              {% set combined = combined + [t] %}
                            {% endif %}
                          {% endfor %}
                        {% endif %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}
                {% endif %}
              <div class="all-tags-inline" data-list-id="{{ lst.id }}" data-list-tags='{{ combined|default([]) | tojson }}' data-combined='{{ combined|default([]) | tojson }}' aria-hidden="{{ 'false' if combined|length > 0 else 'true' }}">
                {# Debug: emit combined length and server-side combined map so we can confirm values in snapshot #}
                <!-- combined_len: {{ combined|length }} -->
                <!-- server_list_combined_snapshot_marker -->
                {% if combined|length > 0 %}
                  {% set csorted = combined | sort %}
                  {% for tag in csorted %}
                    &nbsp;<a href="/html_no_js/search?q={{ tag|urlencode }}" class="tag-chip">{{ tag }}</a>
                  {% endfor %}
                {% endif %}
              </div>
            </div>
          </li>
        {% endfor %}
      </ul>
    </li>
  {% endif %}

  {# Render each category section in category.position order #}
  {% for cat in categories %}
  {% set cat_lists = lists_by_category.get(cat.id, []) %}
    {% if cat_lists and cat_lists|length > 0 %}
      <li class="category-section" data-category-id="{{ cat.id }}">
        <h3 class="category-header" data-target="cat-{{ cat.id }}" style="cursor:pointer; user-select:none;">
          <span class="twisty" aria-hidden="true">‚ñæ</span>
          <span class="category-name">{{ cat.name }}</span>
          <span class="count muted"> ({{ cat_lists|length }})</span>
        </h3>
        <ul id="cat-{{ cat.id }}" class="category-lists">
          {% for lst in cat_lists %}
            {% set created_iso = lst.created_at|in_tz(client_tz, '%Y-%m-%dT%H:%M:%S') %}
            {% set modified_iso = lst.modified_at|in_tz(client_tz, '%Y-%m-%dT%H:%M:%S') if lst.modified_at else None %}
            {# effective priority: use override_priority when present and higher than list.priority #}
            {% set eff = lst.override_priority if (lst.override_priority is not none and (lst.priority is none or lst.override_priority > lst.priority)) else lst.priority %}
            <li class="list-item"{% if created_iso %} data-created-at="{{ created_iso }}"{% endif %}{% if modified_iso %} data-modified-at="{{ modified_iso }}"{% endif %} data-priority="{{ eff if eff is not none else '' }}">
              <div class="list-main">
                <a class="list-title {% if lst.completed %}done{% endif %}" href="/html_no_js/lists/{{ lst.id }}">{{ lst.name }}</a>
                <!--<button type="button" class="list-action-btn edit-list-btn" data-list-id="{{ lst.id }}" data-list-name="{{ lst.name|e }}" title="Edit list name">‚úèÔ∏è</button>-->
                {% set circ = {0:'‚ì™',1:'‚ë†',2:'‚ë°',3:'‚ë¢',4:'‚ë£',5:'‚ë§',6:'‚ë•',7:'‚ë¶',8:'‚ëß',9:'‚ë®',10:'‚ë©'} %}
                {% if lst.priority %}
                  <span class="meta priority-inline"><span class="priority-circle">{{ circ.get(lst.priority, lst.priority) }}</span></span>
                {% endif %}
                {% if lst.override_priority and (lst.priority is none or lst.override_priority > lst.priority) %}
                  <span class="meta priority-inline priority-override" title="Highest uncompleted todo priority"><span class="priority-circle">{{ circ.get(lst.override_priority, lst.override_priority) }}</span></span>
                {% endif %}
                {% if lst.uncompleted_count is not none and not (lst.hide_icons|default(false)) %}
                  <span class="count-circle colour" aria-hidden="false" title="{{ circ.get(lst.uncompleted_count, lst.uncompleted_count) }} uncompleted todos">{{ lst.uncompleted_count }}</span>
                {% endif %}
                {% if lst.created_at %}
                  <div class="meta">cr. {{ lst.created_at|in_tz(client_tz, '%d/%m %-I:%M%p') }}</div>
                {% endif %}
                {# Build combined tags first so data-combined and anchors can be rendered into the div below #}
                {# Prefer server-computed `lst.combined_full` when present for robust SSR and client merging #}
                {% if lst.combined is defined and lst.combined is not none %}
                  {% set combined = lst.combined %}
                {% else %}
                  {% set combined = [] %}
                  {% if lst.hashtags %}
                    {% for t in lst.hashtags %}
                      {% if t not in combined %}
                        {% set combined = combined + [t] %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}
                  {% if lists is defined %}
                    {% for lrow in lists %}
                      {% if lrow.id == lst.id %}
                        {% if lrow.hashtags is defined and lrow.hashtags %}
                          {% for t in lrow.hashtags %}
                            {% if t not in combined %}
                              {% set combined = combined + [t] %}
                            {% endif %}
                          {% endfor %}
                        {% endif %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}
                {% endif %}
                <div class="all-tags-inline" data-list-id="{{ lst.id }}" data-list-tags='{{ combined|default([]) | tojson }}' data-combined='{{ combined|default([]) | tojson }}' aria-hidden="{{ 'false' if combined|length > 0 else 'true' }}">
                {% if combined|length > 0 %}
                  {% set csorted = combined | sort %}
                  {% for tag in csorted %}
                    &nbsp;<a href="/html_no_js/search?q={{ tag|urlencode }}" class="tag-chip">{{ tag }}</a>
                  {% endfor %}
                {% endif %}
                </div>
              </div>
            </li>
          {% endfor %}
        </ul>
      </li>
    {% endif %}
  {% endfor %}
  </ul>

<!-- Section: Quick link to categories page -->
<div style="margin-bottom:0.75rem;">
  <a href="/html_no_js/categories" class="btn" style="font-weight:bold;">‚Üí Categories</a>
</div>

<!-- Section: Embed server-provided categories JSON -->
<script type="application/json" id="server-categories">{{ categories | default([]) | tojson | safe }}</script>
<script>
  (function(){
    try{
      var el = document.getElementById('server-categories');
      var txt = el ? (el.textContent || el.innerText || '').trim() : '[]';
      window.categories = txt ? JSON.parse(txt) : [];
    }catch(e){ window.categories = []; }
  })();
</script>


<!-- Section: Hide Completed control (cookie persisted) -->
<div id="hide-completed-control" style="margin:0.5rem 0;">
  <label><input type="checkbox" id="hide-completed-checkbox"> Hide Completed</label>
  <span class="meta" style="margin-left:0.5rem; color: var(--muted, #6b7280);"></span>
  <!-- meta reserved for future counts or hints -->
  
</div>

<!-- Section: Show all tags control (cookie persisted) -->
<div id="sort-and-tags" style="margin-top:1rem; display:flex; gap:1rem; align-items:center; flex-wrap:wrap;">
  <label style="margin-right:0.5rem;"><input type="checkbox" id="show-all-tags-checkbox"> Show all tags</label>
  <span style="flex:1 1 auto"></span>
  <label>Sort lists: 
    <select id="list-sort-order">
      <option value="created">by creation date</option>
      <option value="modified">by modification date</option>
    </select>
  </label>
</div>
{% endblock %}



{% block scripts %}
<!-- Section: Scripts (sorting, hide completed, rename, collapsible categories, show all tags) -->
{{ super() }}
<script>
// Script: Sorting within categories by created_at or modified_at; persisted in a cookie
(function(){
  function setCookie(name, value, days){ var expires=''; if(days){ var d=new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); expires='; expires='+d.toUTCString(); } document.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/'; }
  function getCookie(name){ var m = document.cookie.match('(?:^|; )' + name + '=([^;]*)'); return m ? decodeURIComponent(m[1]) : null; }
  var sel = document.getElementById('list-sort-order'); if (!sel) return;
  var cookieName = 'index_list_sort_order';
  var cur = getCookie(cookieName) || 'created';
  sel.value = (cur === 'modified') ? 'modified' : 'created';

  function parseISO(v){ try { return v ? new Date(v).getTime() : 0; } catch(_) { return 0; } }
  function parsePri(el){
    try { if (el.classList && el.classList.contains('done')) return null; if (el.querySelector && el.querySelector('.done')) return null; } catch(e) {}
    var v = el.getAttribute('data-priority'); if (v==null || v==='') return null; var n = parseInt(v,10); return isNaN(n) ? null : n; }
  function sortUl(ul){
    var lis = Array.from(ul.querySelectorAll(':scope > li.list-item'));
    // determine category id for this ul by traversing up to .category-section
    var catSection = ul.closest('.category-section');
    var catId = null;
    try { catId = catSection ? catSection.getAttribute('data-category-id') : null; } catch(e) { catId = null; }
    lis.sort(function(a,b){
      var pa = parsePri(a), pb = parsePri(b);
      var aHas = (pa !== null), bHas = (pb !== null);
      if (aHas && !bHas) return -1; // priority first
      if (!aHas && bHas) return 1;
  if (aHas && bHas && pa !== pb) return pb - pa; // higher number first
      // If this category requests alphanumeric sorting, sort by visible list title
      try {
        if (catId && categorySortMap && categorySortMap[catId]) {
          var an = (a.querySelector && a.querySelector('.list-title')) ? (a.querySelector('.list-title').textContent || '') : (a.textContent || '');
          var bn = (b.querySelector && b.querySelector('.list-title')) ? (b.querySelector('.list-title').textContent || '') : (b.textContent || '');
          // localeCompare for alphanumeric-ish ordering
          return an.localeCompare(bn, undefined, {numeric: true, sensitivity: 'base'});
        }
      } catch(e) {
        // fall back to date-based sorting on error
      }
      // tie-breaker: selected date newest first
      var ad = 0, bd = 0;
      if (sel.value === 'modified') {
        ad = parseISO(a.getAttribute('data-modified-at')) || parseISO(a.getAttribute('data-created-at'));
        bd = parseISO(b.getAttribute('data-modified-at')) || parseISO(b.getAttribute('data-created-at'));
      } else {
        ad = parseISO(a.getAttribute('data-created-at'));
        bd = parseISO(b.getAttribute('data-created-at'));
      }
      return bd - ad; // newest first
    });
    lis.forEach(function(li){ ul.appendChild(li); });
  }
  function applySort(){
  document.querySelectorAll('ul.category-lists').forEach(function(ul){ sortUl(ul); });
  }
  sel.addEventListener('change', function(){ setCookie(cookieName, sel.value, 365); applySort(); });
  // initial
  // Build a map of category id -> sort_alphanumeric from server-rendered `categories` var
  var categorySortMap = {};
  try {
    if (typeof window !== 'undefined' && window.categories && Array.isArray(window.categories)) {
      window.categories.forEach(function(c){ categorySortMap[String(c.id)] = !!c.sort_alphanumeric; });
    } else {
      // try to read categories from a global JSON embedded by server (Jinja will set `categories` var)
      if (typeof categories !== 'undefined' && Array.isArray(categories)) {
        categories.forEach(function(c){ categorySortMap[String(c.id)] = !!c.sort_alphanumeric; });
      }
    }
  } catch(e) { /* ignore */ }
  applySort();
})();
// react to category sort changes coming from other tabs/pages
window.addEventListener && window.addEventListener('storage', function(ev){
  if (!ev || !ev.key) return;
  try {
    if (ev.key === 'category_sort_changed'){
      var obj = JSON.parse(ev.newValue || '{}');
      if (obj && obj.id != null){
        categorySortMap[String(obj.id)] = !!obj.sort;
        // reapply sorting across category lists
        document.querySelectorAll('ul.category-lists').forEach(function(ul){ try{ ul && ul.dispatchEvent(new CustomEvent('reapply-sort')); }catch(e){} });
        // also directly call applySort if available
        try { if (typeof applySort === 'function') applySort(); } catch(e){}
      }
    }
  } catch(e) {}
});
  // Remove any leftover suggestion box elements on the index page to fully disable it here
  try {
    var h1 = document.getElementById('hashtag-suggest'); if (h1) h1.remove();
    var h2 = document.getElementById('todo-hashtag-suggest'); if (h2) h2.remove();
  } catch(e) { /* ignore */ }
</script>
<script>
// Log: Creating a sublist (index page)
(function(){
  try{
    document.addEventListener('submit', function(ev){
      var form = ev && ev.target; if (!form || form.tagName !== 'FORM') return;
      var action = form.getAttribute('action') || '';
      if (action.indexOf('/sublists/create') === -1) return;
      try{
        var nameInput = form.querySelector('input[name="name"]');
        var txt = nameInput && nameInput.value ? String(nameInput.value).trim() : '';
        if (!txt) return;
        var parentName = '';
        try{
          var li = form.closest('li.list-item');
          if (li){ var a = li.querySelector('a.list-title'); if (a) parentName = (a.textContent||'').trim(); }
        }catch(_){ }
        if (window.ftLog){ window.ftLog('Added sublist', { item_type: 'list', item_id: null, label: (parentName ? (parentName + ' ‚Äî ') : '') + txt }); }
      }catch(_){ }
    }, false);
  }catch(e){}
})();
</script>
<script>
// Script: Hide Completed lists (persisted via cookie); hides li.list-item whose title has class 'done'
(function(){
  function setCookie(name, value, days){ var expires=''; if(days){ var d=new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); expires='; expires='+d.toUTCString(); } document.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/'; }
  function getCookie(name){ var m = document.cookie.match('(?:^|; )' + name + '=([^;]*)'); return m ? decodeURIComponent(m[1]) : null; }
  var cb = document.getElementById('hide-completed-checkbox'); if (!cb) return;
  var cookieName = 'index_hide_completed_lists';
  cb.checked = getCookie(cookieName) === '1';
  function apply(){
    var hide = cb.checked;
    document.querySelectorAll('ul.category-lists > li.list-item').forEach(function(li){
      var isDone = !!li.querySelector('.list-title.done');
      li.style.display = (hide && isDone) ? 'none' : '';
    });
    // update category counts to reflect hidden items
    try{
      document.querySelectorAll('.category-section').forEach(function(section){
        var ul = section.querySelector('ul.category-lists');
        if (!ul) return;
        var total = ul.querySelectorAll(':scope > li.list-item').length;
        var visible = ul.querySelectorAll(':scope > li.list-item:not([style*="display: none"])').length;
        var countSpan = section.querySelector('.count');
        if (countSpan) countSpan.textContent = ' (' + visible + ')';
      });
    }catch(e){}
  }
  cb.addEventListener('change', function(){ setCookie(cookieName, cb.checked ? '1' : '0', 365); apply(); });
  // initial
  apply();
})();
</script>
<!-- overflow-debug script removed -->

<script>
// Script: Minimal rename using prompt(); posts new name to server endpoint
(function(){
  document.querySelectorAll('.edit-list-btn').forEach(function(btn){
    btn.addEventListener('click', function(){
      var id = btn.getAttribute('data-list-id');
      var current = btn.getAttribute('data-list-name') || '';
      var name = window.prompt('New list name', current);
      if (!name || name.trim() === '' ) return;
          // POST as form so CSRF macro and server accept it
          var fd = new FormData();
          fd.append('name', name);
          // include csrf from page if present
          var csrfInput = document.querySelector('input[name="_csrf"]');
          if (csrfInput && csrfInput.value) fd.append('_csrf', csrfInput.value);
          fetch('/html_no_js/lists/' + encodeURIComponent(id) + '/edit', { method: 'POST', body: fd, credentials: 'same-origin' })
            .then(function(res){
              if (!res.ok) throw new Error('Rename failed');
              return res.json().catch(function(){ return null; });
            })
            .then(function(data){
              try{ if (window.__ft_onListRenamed) window.__ft_onListRenamed(id, name); } catch(e){}
            })
            .catch(function(){ alert('Rename failed'); });
    });
  });
})();
</script>

<script>
// Script: Collapsible category sections with localStorage persistence
(function(){
  function storageKey(id){ return 'cat-collapsed-' + id; }
  function isCollapsed(id){ try { return localStorage.getItem(storageKey(id)) === '1'; } catch(e){ return false; } }
  function setCollapsed(id, v){ try { localStorage.setItem(storageKey(id), v ? '1' : '0'); } catch(e){} }
  function applyState(header){
    var targetId = header.getAttribute('data-target');
    var ul = document.getElementById(targetId);
    if (!ul) return;
    var id = header.parentElement && header.parentElement.getAttribute('data-category-id') || targetId;
    var collapsed = isCollapsed(id);
    ul.style.display = collapsed ? 'none' : '';
    var twisty = header.querySelector('.twisty');
    if (twisty) twisty.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
  }
  document.querySelectorAll('.category-header').forEach(function(h){
    applyState(h);
    h.addEventListener('click', function(){
      var id = h.parentElement && h.parentElement.getAttribute('data-category-id') || h.getAttribute('data-target');
      var now = !isCollapsed(id);
      setCollapsed(id, now);
      applyState(h);
    });
  });
})();
</script>

<script>
// Script: Show All Tags control: store state in a cookie and fetch combined tags per list
(function(){
  function setCookie(name, value, days){
    var expires = '';
    if (days){
      var d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
      expires = '; expires=' + d.toUTCString();
    }
    document.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/';
  }
  function getCookie(name){
    var v = document.cookie.match('(?:^|; )' + name + '=([^;]*)');
    return v ? decodeURIComponent(v[1]) : null;
  }

  var checkbox = document.getElementById('show-all-tags-checkbox');
  if (!checkbox) return;
  // helper: shallow array equality for small tag arrays
  function arraysEqual(a,b){
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    for (var i=0;i<a.length;i++){ if (String(a[i]) !== String(b[i])) return false; }
    return true;
  }
  // initialize state
  var state = getCookie('show_all_tags') === '1';
  checkbox.checked = state;

  function clearAllTagPlaceholders(){
    document.querySelectorAll('.all-tags-inline').forEach(function(c){ c.innerHTML = ''; c.setAttribute('aria-hidden','true'); });
  }

  function renderTagsInto(container, tags){
    container.innerHTML = '';
    tags.forEach(function(tag){
      var a = document.createElement('a');
      a.className = 'tag-chip';
      a.href = '/html_no_js/search?q=' + encodeURIComponent(tag);
      a.textContent = tag;
      container.appendChild(a);
      container.appendChild(document.createTextNode(' '));
    });
    container.setAttribute('aria-hidden','false');
  }

  async function fetchCombinedTags(listId){
    try{
      // Primary attempt: include both todo tags and immediate sublists' tags
      var url1 = '/lists/' + encodeURIComponent(listId) + '/hashtags?include_todo_tags=1&include_sublists=1&combine=1';
      var resp = await fetch(url1, { credentials: 'same-origin' });
      if (resp && resp.ok){
        var data = await resp.json();
        var arr = (data && Array.isArray(data.hashtags)) ? data.hashtags : [];
        if (arr && arr.length) return arr;
      }
      // Fallback A: only include sublists (list-level + their todos)
      var url2 = '/lists/' + encodeURIComponent(listId) + '/hashtags?include_sublists=1&combine=1';
      resp = await fetch(url2, { credentials: 'same-origin' });
      if (resp && resp.ok){
        data = await resp.json();
        arr = (data && Array.isArray(data.hashtags)) ? data.hashtags : [];
        if (arr && arr.length) return arr;
      }
      // Fallback B: include only todo-level tags (no sublists), combined
      var url3 = '/lists/' + encodeURIComponent(listId) + '/hashtags?include_todo_tags=1&combine=1';
      resp = await fetch(url3, { credentials: 'same-origin' });
      if (resp && resp.ok){
        data = await resp.json();
        arr = (data && Array.isArray(data.hashtags)) ? data.hashtags : [];
        if (arr && arr.length) return arr;
      }
      return [];
    }catch(e){ return []; }
  }

  async function fetchListTags(listId){
    try{
      var resp = await fetch('/lists/' + encodeURIComponent(listId) + '/hashtags', { credentials: 'same-origin' });
      if (!resp.ok) return [];
      var data = await resp.json();
      return data.hashtags || [];
    }catch(e){ return []; }
  }

  async function refreshAllTags(force){
    force = !!force;
    var containers = document.querySelectorAll('.all-tags-inline');
    containers.forEach(async function(c){
      var lid = c.getAttribute('data-list-id');
      var listTagsJson = c.getAttribute('data-list-tags');
      var listTags = [];
      try{ listTags = listTagsJson ? JSON.parse(listTagsJson) : []; }catch(e){ listTags = []; }

  // If server already rendered tag anchors, prefer leaving the SSR intact
  // unless the user explicitly asked to "Show all tags" (checkbox checked).
  // Detect any anchor in the container (server markup may use different classes).
  var hasServerRendered = !!(c.querySelector && (c.querySelector('.tag-chip') || c.querySelector('a')));

      if (!checkbox.checked){
        if (!force){
          // preserve SSR when possible on passive (non-user) loads
          if (hasServerRendered) {
            return;
          }
          // no SSR anchors, fall back to rendering listTags (server-provided JSON)
          if (listTags && listTags.length) renderTagsInto(c, listTags);
          else { c.innerHTML = ''; c.setAttribute('aria-hidden','true'); }
          return;
        }
        // user explicitly unticked: fetch list-only tags from the API and render
        var list_only = await fetchListTags(lid);
        if (list_only && list_only.length) renderTagsInto(c, list_only);
        else { c.innerHTML = ''; c.setAttribute('aria-hidden','true'); }
        return;
      }

  // checkbox checked: fetch combined tags and render. If server anchors
      // exist and match what we'd render, skip to avoid unnecessary DOM churn
      // unless this is a user-initiated toggle (force=true) ‚Äî force should
      // guarantee the DOM reflects the user's action.
      var combined = await fetchCombinedTags(lid);
      // Merge precedence: SSR anchors (if any) -> server-provided tags (data-list-tags)
      // -> fetched combined tags. This guarantees SSR-only tags are preserved on toggle.
      var merged = [];
      var seenAll = new Set();
      try {
        var ssrAnchors = Array.from(c.querySelectorAll('a')).map(function(a){ return (a && a.textContent) ? String(a.textContent).trim() : ''; }).filter(Boolean);
        ssrAnchors.forEach(function(t){ if (t && !seenAll.has(t)) { seenAll.add(t); merged.push(t); } });
      } catch(e) {}
      (listTags || []).forEach(function(t){ if (t && !seenAll.has(t)) { seenAll.add(t); merged.push(t); } });
      (combined || []).forEach(function(t){ if (t && !seenAll.has(t)) { seenAll.add(t); merged.push(t); } });
  if (!force && hasServerRendered && Array.isArray(listTags) && Array.isArray(merged) && arraysEqual(listTags, merged)) {
        return;
      }
  if (merged && merged.length) renderTagsInto(c, merged);
      else { c.innerHTML = ''; c.setAttribute('aria-hidden','true'); }
    });
  }

  checkbox.addEventListener('change', function(){
  // record the preference and kick off a refresh for the user action.
  setCookie('show_all_tags', checkbox.checked ? '1' : '0', 365);
  try{ console.debug('show_all_tags changed ->', checkbox.checked); }catch(e){}
  // user toggle should force a DOM update even if arraysEqual would otherwise skip it
  refreshAllTags(true);
  });

  // Do not auto-refresh on load. Initial DOM should be SSR-only; JS updates occur on user toggle.
})();
</script>

{% endblock %}

